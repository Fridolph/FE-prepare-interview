import{_ as t,c as a,o as e,V as l}from"./chunks/framework.i1kO8Tor.js";const f=JSON.parse('{"title":"下面为变量类型相关常考察点","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/02js/q_js_1-base.md","filePath":"面试官问/02js/q_js_1-base.md","lastUpdated":null}'),i={name:"面试官问/02js/q_js_1-base.md"},o=l('<h1 id="下面为变量类型相关常考察点" tabindex="-1">下面为变量类型相关常考察点 <a class="header-anchor" href="#下面为变量类型相关常考察点" aria-label="Permalink to &quot;下面为变量类型相关常考察点&quot;">​</a></h1><p>若有陌生或不清楚的可再到 <a href="./../../直击概念/02js/s_js_1-base.html">直击概念 - 变量</a> 回顾</p><h2 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h2><h3 id="js-有多少种数据类型" tabindex="-1">JS 有多少种数据类型 <a class="header-anchor" href="#js-有多少种数据类型" aria-label="Permalink to &quot;JS 有多少种数据类型&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>基本类型 7 <ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li><li>Symbol</li><li>BigInt</li></ul></li><li>引用类型：Object <ul><li>Array、Function、Date、RegExp、Error 等</li></ul></li></ul></details><h3 id="let、const-和-var-的区别" tabindex="-1">let、const 和 var 的区别 <a class="header-anchor" href="#let、const-和-var-的区别" aria-label="Permalink to &quot;let、const 和 var 的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><table><thead><tr><th>特性</th><th>let</th><th>const</th><th>var</th></tr></thead><tbody><tr><td>变量提升</td><td>无，暂时性死区</td><td>无，暂时性死区</td><td>存在变量提升</td></tr><tr><td>立即赋值</td><td>不需</td><td>需要</td><td>不需</td></tr><tr><td>可修改</td><td>可修改</td><td>基础类型不可修改，引用类型赋值后可修改</td><td>可修改</td></tr></tbody></table></details><h2 id="判断" tabindex="-1">判断 <a class="header-anchor" href="#判断" aria-label="Permalink to &quot;判断&quot;">​</a></h2><h3 id="typeof-的用法" tabindex="-1">typeof 的用法 <a class="header-anchor" href="#typeof-的用法" aria-label="Permalink to &quot;typeof 的用法&quot;">​</a></h3><details class="details custom-block"><summary>点击提示</summary><p><strong>typeof</strong></p><ul><li>判断所有值类型：number、string、boolean、undefined、symbol、bigint</li><li>能识别函数 function</li><li>判断是否为引用类型 （但不能细分）</li><li>null 会被判断为 object</li></ul></details><h3 id="instanceof-的用法" tabindex="-1">instanceof 的用法 <a class="header-anchor" href="#instanceof-的用法" aria-label="Permalink to &quot;instanceof 的用法&quot;">​</a></h3><details class="details custom-block"><summary>点击提示</summary><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p></details><h3 id="typeof-与-instanceof-的区别" tabindex="-1">typeof 与 instanceof 的区别 <a class="header-anchor" href="#typeof-与-instanceof-的区别" aria-label="Permalink to &quot;typeof 与 instanceof 的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><table><thead><tr><th>特性</th><th>typeof</th><th>instanceof</th></tr></thead><tbody><tr><td>返回类型</td><td>返回一个变量的基本类型</td><td>返回的是一个布尔值</td></tr><tr><td>判断范围</td><td>基础数据类型(null除外)和function</td><td>准确地判断复杂引用数据类型</td></tr></tbody></table><ul><li><code>返回结果类型不同</code>：typeof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值</li><li><code>判断范围不同</code>：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</li></ul></details><h3 id="object-is-与比较操作符-、-的区别" tabindex="-1">Object.is() 与比较操作符 “===”、“==” 的区别 <a class="header-anchor" href="#object-is-与比较操作符-、-的区别" aria-label="Permalink to &quot;Object.is() 与比较操作符 “===”、“==” 的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行<code>强制类型转化</code>后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，<code>不会做强制类型准换</code>，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它<code>处理了一些特殊的情况</code>，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul></details><h3 id="对于-和-比较符" tabindex="-1">对于 &lt; 和 &gt; 比较符 <a class="header-anchor" href="#对于-和-比较符" aria-label="Permalink to &quot;对于 &lt; 和 &gt; 比较符&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>如果两边都是字符串，则比较字母表顺序，<code>&#39;a&#39; &lt; &#39;b&#39; -&gt; true</code></li><li>其他情况下，转换为数字再比较 <code>&#39;12&#39; &lt; 4 -&gt; true</code>，<code>false &gt; -1 -&gt; true</code></li></ul></details><h2 id="运算" tabindex="-1">运算 <a class="header-anchor" href="#运算" aria-label="Permalink to &quot;运算&quot;">​</a></h2><h3 id="为什么-0-1-0-2-0-3-如何让其相等" tabindex="-1">为什么 0.1+0.2 ! == 0.3，如何让其相等 <a class="header-anchor" href="#为什么-0-1-0-2-0-3-如何让其相等" aria-label="Permalink to &quot;为什么 0.1+0.2 ! == 0.3，如何让其相等&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>计算机是通过二进制的方式存储数据的，所以计算机计算 0.1+0.2 的时候，实际上是计算的两个数的二进制的和。0.1 的二进制是 0.0001100110011001100...（1100 循环），0.2 的二进制是：0.00110011001100...（1100 循环），这两个数的二进制都是无限循环的数。</p></details><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7227787460968415289" target="_blank" rel="noreferrer">前端（HTML+CSS+JS+打包+环境+网络）2023</a></li></ul>',23),s=[o];function d(r,n,c,h,u,m){return e(),a("div",null,s)}const _=t(i,[["render",d]]);export{f as __pageData,_ as default};
