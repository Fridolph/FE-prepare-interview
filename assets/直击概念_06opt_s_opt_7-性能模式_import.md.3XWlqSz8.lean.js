import{_ as p,E as h,c as t,J as a,V as n,m as s,a as l,o as e}from"./chunks/framework.VAJu91au.js";const K=JSON.parse('{"title":"Import","description":"","frontmatter":{},"headers":[],"relativePath":"直击概念/06opt/s_opt_7-性能模式_import.md","filePath":"直击概念/06opt/s_opt_7-性能模式_import.md","lastUpdated":1723565816000}'),k={name:"直击概念/06opt/s_opt_7-性能模式_import.md"},r=n("",20),E=s("h3",{id:"验证-authentication",tabindex:"-1"},[l("验证 Authentication "),s("a",{class:"header-anchor",href:"#验证-authentication","aria-label":'Permalink to "验证 Authentication"'},"​")],-1),d=s("p",null,"应用程序可能需要通过客户端 JavaScript SDK 支持与服务进行身份验证。这些可能会偶尔占用大量内存并产生大量的 JS 执行成本，如果用户不打算登录，可能不希望急切地一开始就加载它们。相反，当用户点击“登录”按钮时动态导入认证库，从而在初始加载时保持主线程更自由。",-1),g=s("h3",{id:"聊天小部件",tabindex:"-1"},[l("聊天小部件 "),s("a",{class:"header-anchor",href:"#聊天小部件","aria-label":'Permalink to "聊天小部件"'},"​")],-1),c=s("p",null,"Calibre 应用通过使用类似的外观方法提高了基于 Intercom 的实时聊天的性能，提升了约百分之三十。他们使用 CSS 和 HTML 实现了一个“假的”快速加载的实时聊天按钮，点击后加载他们的 Intercom 包。 Postmark 注意到他们的帮助聊天小部件总是热加载，尽管这只是偶尔被客户使用。该小部件会加载额外的 314KB 脚本，比整个主页还要大。为了提高用户体验，他们使用 HTML 和 CSS 创建了一个虚假的小部件复制品，只有在点击时才加载真正的程序。这个变化使得互动性等待时间从原本的 7.7 秒减少到现在的 3.7 秒。",-1),o=n("",3),y=n("",12),b=n("",12),u=s("p",null,"为了提高性能通常我们使用特定的代码实现如渐进式加载这样的策略，例如延迟加载、按需加载等，以便减少用户的等待时间并加快页面渲染速度。",-1),m=s("p",null,"接下来，想象一下这个体验转移到服务器端渲染（SSR）。我们将允许用户更快地获得视觉上的完整页面，这非常好，但是，在服务器获取数据并且客户端框架完成补水之前，它不会具有交互性。",-1),F=s("p",null,"服务器端渲染可能是一种改进，但用户可能会经历一个令人不安的落差感，页面看起来已经准备就绪，但他们无法点击任何内容。有时这被称为愤怒点击，因为用户往往会因沮丧而反复点击。",-1),C=s("p",null,"回到谷歌酒店搜索的例子，如果我们稍微缩小一点界面可以看到，当用户点击“更多过滤器”来找到确切的酒店时，该组件所需的代码会被下载下来。",-1),_=s("p",null,"最初仅下载非常少量的代码，之后用户的交互决定何时发送更多代码。让我们更仔细地看一下这种加载场景。",-1),A=s("p",null,"交互驱动延迟加载有很多重要的方面：",-1),D=s("ul",null,[s("li",null,"首先，我们一开始下载的代码量最少，以便页面可以快速完整地呈现。"),s("li",null,"其次，在用户开始与页面交互时，我们使用这些交互来确定要加载哪些其他代码。例如加载“更多过滤器”组件的代码。"),s("li",null,"这意味着页面上的许多功能的代码都不会发送到浏览器，因为用户并不需要这些功能。")],-1),B=s("h3",{id:"我们如何避免早期点击丢失",tabindex:"-1"},[l("我们如何避免早期点击丢失？ "),s("a",{class:"header-anchor",href:"#我们如何避免早期点击丢失","aria-label":'Permalink to "我们如何避免早期点击丢失？"'},"​")],-1),v=s("p",null,"在这些谷歌团队使用的框架堆栈中，我们可以尽早跟踪点击，因为 HTML 的第一块包含一个事件库（JSAction），在框架启动之前跟踪所有点击事件。",-1),f=s("p",null,"这些事件用于两件事：根据用户交互触发组件代码的下载当框架完成启动后重现用户交互。",-1),P=s("p",null,"其他可能采用的启发式方法包括加载组件代码：在用户空闲时间后的一段时间内；在用户鼠标悬停在相关用户界面/按钮上或者发生行动调用时基于浏览器信号（例如网络速度、数据节省模式等）的渴望程度滑动比例。",-1),S=s("h3",{id:"关于数据呢",tabindex:"-1"},[l("关于数据呢？ "),s("a",{class:"header-anchor",href:"#关于数据呢","aria-label":'Permalink to "关于数据呢？"'},"​")],-1),T=s("p",null,"用于渲染页面的初始数据包含在初始页面的服务器端渲染 HTML 中并进行了流式传输。",-1),j=s("p",null,"根据用户交互下载延迟加载的数据，因为我们知道它与哪个组件相关联。这使得数据与数据获取一起，以类似于 CSS 和 JS 运行的方式完成了交互时导入图片的任务。由于组件了解自身所需的代码和数据，因此它需要的所有资源都不超过一个请求的距离。",-1),I=n("",9),q=s("p",null,"如果优化性能，可以将嵌入完全替换为外观相似的静态变体，并链接到更互动的版本（例如，原始社交媒体帖子）。在构建时，可以提取嵌入的数据并将其转换为静态 HTML 版本。这样可以减少初始加载的负担，提高页面性能，同时依然能保持内容的可获取性。",-1),x=s("p",null,"这是针对一种社交媒体嵌入所采取的方法，这种方法提高了页面加载性能，消除了由于嵌入代码增强后备文本导致的累积布局移位问题。虽然静态替代可能对性能有益，但它们通常需要定制化的内容，因此在评估选项时需要注意这一点。",-1),M=s("h2",{id:"小结",tabindex:"-1"},[l("小结 "),s("a",{class:"header-anchor",href:"#小结","aria-label":'Permalink to "小结"'},"​")],-1),L=s("p",null,"第一方的 JavaScript 经常影响现代网页的交互就绪性，但其经常被来自第一方或第三方源的非关键 JavaScript 在网络上的延迟所阻碍，后者会让主线程保持忙碌状态。",-1),V=s("p",null,"一般来说，避免在文档头部使用同步的第三方脚本，并尽量在第一方 JS 加载完成后加载非阻塞的第三方脚本。像按需加载的模式给我们提供了一种方式来延迟加载非关键资源，直到用户更可能需要这些资源支持的用户界面为止。",-1);function w(J,R,N,H,O,z){const i=h("Image");return e(),t("div",null,[r,a(i,{src:"/06opt/loadYouTube.png",alt:"loadYouTube"}),E,d,a(i,{src:"/06opt/Authentication.png",alt:"Authentication"}),g,c,a(i,{src:"/06opt/loadHelp.png",alt:"loadHelp"}),o,a(i,{src:"/06opt/Others.png",alt:"Others"}),y,a(i,{src:"/06opt/openEmojiPicker.png",alt:"openEmojiPicker"}),b,a(i,{src:"/06opt/basic-client-side-rendering.png",alt:"basic-client-side-rendering"}),u,m,F,a(i,{src:"/06opt/basic-server-side-rendering.png",alt:"basic-server-side-rendering"}),C,_,A,D,a(i,{src:"/06opt/driven-late-loading.png",alt:"driven-late-loading"}),B,v,f,P,a(i,{src:"/06opt/avoid-clicks.png",alt:"avoid-clicks"}),S,T,j,a(i,{src:"/06opt/data-fetching-work.png",alt:"data-fetching-work"}),I,a(i,{src:"/06opt/staticHtml.png",alt:"staticHtml"}),q,x,M,L,V])}const $=p(k,[["render",w]]);export{K as __pageData,$ as default};
