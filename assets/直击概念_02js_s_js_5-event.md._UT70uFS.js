import{_ as i,c as s,o as a,V as e}from"./chunks/framework.cwIXGwyx.js";const g=JSON.parse('{"title":"Event 事件","description":"","frontmatter":{},"headers":[],"relativePath":"直击概念/02js/s_js_5-event.md","filePath":"直击概念/02js/s_js_5-event.md","lastUpdated":1708674619000}'),t={name:"直击概念/02js/s_js_5-event.md"},l=e(`<h1 id="event-事件" tabindex="-1">Event 事件 <a class="header-anchor" href="#event-事件" aria-label="Permalink to &quot;Event 事件&quot;">​</a></h1><p>事件是你正在编程的系统中发生的事情，系统会告诉你有关这些事件的信息，以便你的代码能够对它们做出反应。</p><h2 id="什么是事件" tabindex="-1">什么是事件 <a class="header-anchor" href="#什么是事件" aria-label="Permalink to &quot;什么是事件&quot;">​</a></h2><p>当事件发生时，系统产生（或“触发”）某种信号，并提供一种机制，当事件发生时，可以自动采取某种行动（即运行一些代码）。事件是在浏览器窗口内触发的，并倾向于附加到驻留在其中的特定项目。这可能是一个单一的元素，一组元素，当前标签中加载的 HTML 文档，或整个浏览器窗口。有许多不同类型的事件可以发生。</p><p>例如：</p><ul><li>用户选择、点击或将光标悬停在某一元素上。</li><li>用户在键盘中按下某个按键。</li><li>用户调整浏览器窗口的大小或者关闭浏览器窗口。</li><li>网页结束加载。</li><li>表单提交。</li><li>视频播放、暂停或结束。</li><li>发生错误。</li></ul><div class="tip custom-block"><p class="custom-block-title">提示</p><p>为了对一个事件做出反应，你要给它附加一个事件处理器。这是一个代码块，在事件发生时运行。当这样一个代码块被定义为响应一个事件而运行时，我们说我们在注册一个事件处理器。</p><p>注意：web 事件不是 JavaScript 语言的核心——它们被定义成内置于浏览器的 API</p></div><h3 id="事件对象的额外属性" tabindex="-1">事件对象的额外属性 <a class="header-anchor" href="#事件对象的额外属性" aria-label="Permalink to &quot;事件对象的额外属性&quot;">​</a></h3><p>大多数事件对象都有一套标准的属性和方法，请参阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event" target="_blank" rel="noreferrer">Event</a> 对象参考，以获得完整的列表。</p><h2 id="事件对象" tabindex="-1">事件对象 <a class="header-anchor" href="#事件对象" aria-label="Permalink to &quot;事件对象&quot;">​</a></h2><p>有时候在事件处理函数内部，你可能会看到一个固定指定名称的参数，例如 event、evt 或 e。这被称为事件对象，它被自动传递给事件处理函数，以提供额外的功能和信息</p><ul><li>event 就是一个事件对象，写道我们的侦听函数的小括号里面，当形参来看</li><li>事件对象只有有了事件才会存在，他是系统给我们自动创建的，不需要我们传递参数</li><li>事件对象是我们的事件的一系列相关数据的集合，比如鼠标点击里面就包含了鼠标的相关信息</li><li>这个事件对象我们可以自己命名，比如 event、evt 、e 等</li><li>事件对象也有兼容性问题。 IE 6、7、8 通过 window.event 实现</li></ul><h3 id="事件对象常见属性和方法" tabindex="-1">事件对象常见属性和方法 <a class="header-anchor" href="#事件对象常见属性和方法" aria-label="Permalink to &quot;事件对象常见属性和方法&quot;">​</a></h3><table><thead><tr><th>事件对象属性方法</th><th>说明</th></tr></thead><tbody><tr><td><code>e.target</code></td><td>返回触发事件的对象 标准</td></tr><tr><td>e.type</td><td>返回事件的类型，比如 click、mouseover 等，不带 on</td></tr><tr><td><code>e.preventDefaule()</code></td><td>该方法阻止默认事件（默认行为）标准 ，比如不让链接跳转</td></tr><tr><td><code>e.stopPropagation()</code></td><td>阻止冒泡，标准</td></tr></tbody></table><h2 id="dom-事件流" tabindex="-1">DOM 事件流 <a class="header-anchor" href="#dom-事件流" aria-label="Permalink to &quot;DOM 事件流&quot;">​</a></h2><p>事件流描述的是从页面中接收事件的顺序。通常，一个事件会从父元素开始向目标元素传播，然后它将被传播回父元素。</p><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。包括以下三个阶段：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p>我们知道，在 dom 模型中，html 是多层次的，当一个 html 元素上产生事件时，该事件会在 dom 树元素节点之间按照特定的顺序去传播。传播路径的每一个节点，都会收到这个事件，这就是 dom 事件流。当事件发生后，就会从内向外逐级传播，因为事件流本身没有处理事件的能力，所以，处理事件的函数并不会绑定在该事件源上。例如我们点击了一个按钮，产生了一个 click 事件，click 事件就会开始向上传播，一直到到处理这个事件的代码中。</p><h3 id="事件捕获" tabindex="-1">事件捕获 <a class="header-anchor" href="#事件捕获" aria-label="Permalink to &quot;事件捕获&quot;">​</a></h3><p>事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。</p><p>事件捕获默认是禁用的，你需要在 addEventListener() 的 <code>capture</code> 选项中启用它。</p><h3 id="目标阶段" tabindex="-1">目标阶段 <a class="header-anchor" href="#目标阶段" aria-label="Permalink to &quot;目标阶段&quot;">​</a></h3><p>当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</p><h3 id="事件冒泡" tabindex="-1">事件冒泡 <a class="header-anchor" href="#事件冒泡" aria-label="Permalink to &quot;事件冒泡&quot;">​</a></h3><p>事件按照从最特定的事件目标到最不特定的事件目标(document 对象)的顺序触发，当一个元素接收到事件的时候会把他接收到的事件传给自己的父级，一直到 window 。</p><h2 id="事件委托" tabindex="-1">事件委托 <a class="header-anchor" href="#事件委托" aria-label="Permalink to &quot;事件委托&quot;">​</a></h2><p>只操作了一次 DOM ，提高了程序的性能。</p><h3 id="事件委托的原理" tabindex="-1">事件委托的原理 <a class="header-anchor" href="#事件委托的原理" aria-label="Permalink to &quot;事件委托的原理&quot;">​</a></h3><p>不给每个子节点单独设置事件监听器，而是<code>设置在其父节点</code>上，然后<code>利用冒泡</code>原理设置每个子节点。</p><p>例如： 给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li ，然后事件冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。</p><h3 id="为什么用事件委托" tabindex="-1">为什么用事件委托 <a class="header-anchor" href="#为什么用事件委托" aria-label="Permalink to &quot;为什么用事件委托&quot;">​</a></h3><p>在 JavaScript 中，添加到页面上的事件处理程序数量将<code>直接关系到页面的整体运行性能</code>，因为需要不断的操作 dom,那么引起浏览器<code>重绘和回流</code>的可能也就越多，页面交互的事件也就变的越长，这也就是为什么要<code>减少 dom 操作</code>的原因。</p><p>每一个事件处理函数，都是一个对象，那么多一个事件处理函数，内存中就会被多占用一部分空间。如果要用事件委托，就会将所有的操作放到 js 程序里面，只对它的父级(如果只有一个父级)这一个对象进行操作，与 dom 的操作就<code>只需要交互一次</code>，这样就能大大的<code>减少与 dom 的交互次数</code>，<code>提高性能</code></p><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><p>需求：鼠标放到 li 上，对应的 li 背景颜色变为灰色</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;111&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;222&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;333&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>普通实现</strong>： 给每个 li 都绑定一个事件让其变灰</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;li&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mouseover&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  $</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">css</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background-color&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;gray&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">siblings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">css</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background-color&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;white&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>在这段代码结束以后，我们动态的给 ul 又增加了一个 li，那么新增的这个 li 是不带有事件的，如果有无数个 li 结点，我们的 dom 是吃不消的</p></blockquote><p><strong>使用事件委托实现</strong></p><p>js 中事件是会冒泡的，所以 this 是可以变化的，但 event.target 不会变化，它永远是直接接受事件的目标 DOM 元素</p><p>利用事件冒泡 只指定 ul 的事件处理 就可以控制 ul 下的所有的 li 的事件</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ul&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mouseover&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  $</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.target).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">css</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background-color&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;gray&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">siblings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">css</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;background-color&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;white&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><p>第一步：<code>给父元素绑定事件</code></p><p>给元素 ul 添加绑定事件，绑定 mouseover 事件设置 css（也可通过 addEventListener 为点击事件 click 添加绑定）</p></li><li><p>第二步：<code>监听子元素的冒泡事件</code></p><p>这里默认是冒泡，点击子元素 li 会向上冒泡</p></li><li><p>第三步：<code>找到是哪个子元素的事件</code></p><p>通过匿名回调函数的参数 e 用来接收事件对象，通过 target 获取触发事件的目标（可以通过判断 target 的类型来确定是哪一类的子元素对象执行事件）</p></li></ul><h2 id="自测" tabindex="-1">自测 <a class="header-anchor" href="#自测" aria-label="Permalink to &quot;自测&quot;">​</a></h2><p><a href="./../../面试官问/02js/q_js_5-event.html">面试官问 - 事件 Event</a></p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events" target="_blank" rel="noreferrer">MDN - 事件介绍</a></li><li><a href="https://juejin.cn/post/6965127548980166670" target="_blank" rel="noreferrer">谈谈事件冒泡、事件捕获和事件委托</a></li><li><a href="https://juejin.cn/post/7005558885947965454" target="_blank" rel="noreferrer">简述 JavaScript 的事件捕获和事件冒泡</a></li><li><a href="https://juejin.cn/post/7192584563799883832" target="_blank" rel="noreferrer">JS中的事件冒泡、事件捕获、事件委托</a></li></ul>`,49),n=[l];function h(p,r,k,d,o,E){return a(),s("div",null,n)}const u=i(t,[["render",h]]);export{g as __pageData,u as default};
