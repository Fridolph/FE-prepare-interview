import{_ as l,c as t,o as i,V as a}from"./chunks/framework.i1kO8Tor.js";const _=JSON.parse('{"title":"经典题","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/12broswer/q_bw_1-fromurl.md","filePath":"面试官问/12broswer/q_bw_1-fromurl.md","lastUpdated":null}'),e={name:"面试官问/12broswer/q_bw_1-fromurl.md"},o=a('<h1 id="经典题" tabindex="-1">经典题 <a class="header-anchor" href="#经典题" aria-label="Permalink to &quot;经典题&quot;">​</a></h1><p><a href="./../../直击概念/12broswer/s_bw_1-broswer.html">直击概念 - 浏览器工作原理</a></p><h2 id="从浏览器输入-url-到页面渲染经历了什么" tabindex="-1">从浏览器输入 url 到页面渲染经历了什么 <a class="header-anchor" href="#从浏览器输入-url-到页面渲染经历了什么" aria-label="Permalink to &quot;从浏览器输入 url 到页面渲染经历了什么&quot;">​</a></h2><blockquote><p>先来精简版，见招拆招，避免说一大堆不到重点，面试官若想深究细节，自然会问的</p></blockquote><details class="details custom-block"><summary>详细信息</summary><ol><li>先通过 DNS 解析，拿到 url 对应 IP 地址</li><li>与服务器 “三次握手” 建立 HTTP 连接</li><li>发送 HTTP 请求返 HTML 给浏览器</li><li>判断缓存情况，最终拿到 HTML</li><li>解析 HTML -&gt; 构建 DOM 树</li><li>解析 CSS -&gt; 构建 CSSOM 树</li><li>下载所需 CSS、JS、图片等资源</li><li>Layout 布局，确定渲染树中所有节点的宽度、高度和位置</li><li>RenderTree 绘制 将各个节点绘制到屏幕上</li><li>等待交互</li></ol></details><div class="warning custom-block"><p class="custom-block-title">注意</p><p>构建 DOM 树，构建 CSSOM 树，及下载所需资源这几步没有严格的先后顺序</p></div><h3 id="dns-怎么解析的" tabindex="-1">DNS 怎么解析的 <a class="header-anchor" href="#dns-怎么解析的" aria-label="Permalink to &quot;DNS 怎么解析的&quot;">​</a></h3><details class="details custom-block"><summary>DNS 是应用层协议，用于将用户提供的主机名解析为 ip 地址。具体过程如下：</summary><ol><li><p><strong>浏览器缓存</strong>：当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的 IP 地址（若曾经访问过该域名且没有清空，缓存便存在）</p></li><li><p><strong>系统缓存</strong>：当浏览器缓存中无域名对应 IP 则会检查用户计算机系统 Hosts 文件 DNS 缓存是否有该域名对应的 IP</p></li><li><p><strong>路由器缓存</strong>：当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客户端的 DNS 查询</p></li><li><p><strong>ISP（互联网服务提供商）DNS 缓存</strong>：当在客户端查找不到域名对应 IP 地址，则进入 ISP DNS 缓存中查询</p></li><li><p><strong>根域名服务器</strong>：以上均未完成，则进入根服务器进行查询</p></li><li><p><strong>顶级域名服务器</strong>：顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的 IP 地址告诉本地 DNS 服务器</p></li><li><p><strong>主域名服务器</strong>：主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确记录</p></li><li><p><strong>保存结果至缓存</strong>：本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 web 服务器建立链接</p></li></ol></details><h3 id="说一下三次握手" tabindex="-1">说一下三次握手 <a class="header-anchor" href="#说一下三次握手" aria-label="Permalink to &quot;说一下三次握手&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ol><li><p>客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口</p></li><li><p>服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包</p></li><li><p>客户端发送 ACK=Y+1， Seq=Z</p></li></ol></details><p>TCP 链接建立后发送 HTTP 请求</p><h3 id="说一下四次挥手" tabindex="-1">说一下四次挥手 <a class="header-anchor" href="#说一下四次挥手" aria-label="Permalink to &quot;说一下四次挥手&quot;">​</a></h3><details class="details custom-block"><summary>关闭 TCP 连接的四次挥手如下：</summary><p>浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用：</p><ol><li>客户端 -&gt; 发送释放请求 FIN -&gt; 服务端</li><li>服务端 -&gt; 发送 ACK -&gt; 客户端</li><li>服务端 -&gt; FIN -&gt; 客户端</li><li>客户端 -&gt; ACK + 1 -&gt; 服务端确认并关闭</li></ol></details><h3 id="拿到-html-后-浏览器是如何进行解析和渲染的" tabindex="-1">拿到 HTML 后，浏览器是如何进行解析和渲染的 <a class="header-anchor" href="#拿到-html-后-浏览器是如何进行解析和渲染的" aria-label="Permalink to &quot;拿到 HTML 后，浏览器是如何进行解析和渲染的&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ol><li><p>浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 <code>document.readystate 为 loading</code></p></li><li><p>HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本：</p></li></ol><ul><li>这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。</li><li>这样就可以用 document.write()把文本插入到输入流中。</li><li>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</li></ul><ol start="3"><li>当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档：</li></ol><ul><li>脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。</li><li>异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素</li></ul><ol start="4"><li><p>当文档完成解析，<code>document.readState 变成 interactive</code></p></li><li><p>所有 defer 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()</p></li><li><p>浏览器在 Document 对象上触发 DOMContentLoaded 事件</p></li><li><p>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载， 等这些内容完成载入并且所有异步脚本完成载入和执行，<code>document.readState 变为 complete</code>，window 触发 load 事件</p></li></ol></details><p>完成以上，最后显示页面（HTML 解析过程中会逐步显示页面）</p>',16),r=[o];function s(c,d,n,p,u,m){return i(),t("div",null,r)}const b=l(e,[["render",s]]);export{_ as __pageData,b as default};
