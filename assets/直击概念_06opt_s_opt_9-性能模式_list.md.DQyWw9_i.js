import{_ as i,E as o,c as s,J as n,m as t,a as e,V as _,o as r}from"./chunks/framework.CMKosmpS.js";const S=JSON.parse('{"title":"List Virtualization","description":"","frontmatter":{},"headers":[],"relativePath":"直击概念/06opt/s_opt_9-性能模式_list.md","filePath":"直击概念/06opt/s_opt_9-性能模式_list.md","lastUpdated":1723566143000}'),l={name:"直击概念/06opt/s_opt_9-性能模式_list.md"},c=t("h1",{id:"list-virtualization",tabindex:"-1"},[e("List Virtualization "),t("a",{class:"header-anchor",href:"#list-virtualization","aria-label":'Permalink to "List Virtualization"'},"​")],-1),d=t("p",null,"列表虚拟化",-1),p=t("p",null,"在这份指南中，我们将讨论列表虚拟化（也称为窗口化）。这是一种只渲染动态列表中的可见内容行的思想，而不是整个列表。渲染的行只是全列表的一个小部分，随着用户的滚动，可见内容（窗口）会移动。这可以提高渲染性能。如果你使用 React 并且需要高效地显示大量数据列表，你可能会熟悉 react-virtualized。",-1),u=t("p",null,[e("虚拟化项目列表涉及维护一个窗口并在列表周围移动该窗口。在 react-virtualized 中进行窗口操作的工作原理如下： 有一个具有相对定位（窗口）的小容器 DOM 元素（例如"),t("code",null,"<ul>"),e("）；有一个用于滚动的大 DOM 元素；在容器内部绝对定位子元素，并为其设置顶部、左侧、宽度和高度样式。虚拟化并不专注于一次性渲染数千个列表元素（这可能会导致初始渲染速度较慢或影响滚动性能），而是专注于渲染仅对用户可见的元素。")],-1),h=_('<p>这可以帮助在中低端设备上保持列表渲染的快速性。随着用户滚动，可以获取/显示更多项，将前面的条目卸载并用新条目替换。这种方法有效地管理了内存和渲染性能。</p><h3 id="web-平台的改进" tabindex="-1">Web 平台的改进 <a class="header-anchor" href="#web-平台的改进" aria-label="Permalink to &quot;Web 平台的改进&quot;">​</a></h3><p>现代浏览器现在支持 <strong>CSS content-visibility</strong>。属性 <code>content-visibility: auto</code> 允许浏览器跳过渲染和绘制不在视口中的内容，直到需要时才渲染。如果您在处理需要大量渲染的长 HTML 文档，可以考虑使用此属性。</p><p>对于动态内容列表的渲染，我仍然推荐使用像 React-Window 这样的库。使用 <code>content-visibility: hidden</code> 来实现高效渲染将很具挑战性，相比之下，许多虚拟化库使用的 agresive DOM 节点移除策略更有效。</p><p>具体的还是参考掘金文章了 原文图和视频挂了</p>',5);function m(V,b,v,f,z,T){const a=o("Image");return r(),s("div",null,[c,d,p,u,n(a,{src:"/06opt/ListVirtualization.png",alt:"List Virtualization"}),h])}const x=i(l,[["render",m]]);export{S as __pageData,x as default};
