import{_ as e,c as t,o as a,V as o}from"./chunks/framework.i1kO8Tor.js";const _=JSON.parse('{"title":"HTTPS","description":"","frontmatter":{},"headers":[],"relativePath":"直击概念/04http/s_http_5-https.md","filePath":"直击概念/04http/s_http_5-https.md","lastUpdated":1708674619000}'),r={name:"直击概念/04http/s_http_5-https.md"},h=o('<h1 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h1><p>超文本传输<code>安全</code>协议（HyperText Transfer Protocol Secure）是一种通过计算机网络进行安全通信的<code>传输协议</code>。HTTPS 经由 HTTP 进行通信，但利用 <code>SSL/TLS</code> 来<code>加密数据包</code>。</p><p>HTTPS 开发的主要目的，是<strong>提供对网站服务器的身份认证，保护交换资料的隐私与完整性</strong>。这个协议由网景公司（Netscape）在 1994 年首次提出，随后扩展到互联网上。</p><h2 id="主要作用" tabindex="-1">主要作用 <a class="header-anchor" href="#主要作用" aria-label="Permalink to &quot;主要作用&quot;">​</a></h2><p>HTTPS 的主要作用是在不安全的网络上创建一个安全信道，并可在<code>使用适当的加密包</code>和<code>服务器证书</code>可被验证且可被信任时，对窃听和中间人攻击<code>提供合理的防护</code>。</p><p>HTTPS 的信任基于预先安装在操作系统中的证书颁发机构（CA）。因此，与一个网站之间的 HTTPS 连线仅在这些情况下可被信任：</p><ul><li>浏览器正确地实现了 HTTPS 且操作系统中安装了正确且受信任的证书颁发机构；</li><li>证书颁发机构仅信任合法的网站；</li><li>被访问的网站提供了一个有效的证书，也就是说它是一个由操作系统信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；</li><li>该证书正确地验证了被访问的网站（例如，访问 <code>https://example.com</code> 时收到了签发给<code>example.com</code>而不是其它域名的证书）；</li><li>此协议的加密层（SSL/TLS）能够有效地提供认证和高强度的加密。</li></ul><div class="tip custom-block"><p class="custom-block-title">提示</p><p>不应将 HTTPS 和在<a href="https://tools.ietf.org/html/rfc2660" target="_blank" rel="noreferrer">RFC 2660</a>中定义的<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noreferrer">安全超文本传输协议（S-HTTP）</a>相混淆</p></div><h2 id="https-与-http-的差异" tabindex="-1">HTTPS 与 HTTP 的差异 <a class="header-anchor" href="#https-与-http-的差异" aria-label="Permalink to &quot;HTTPS 与 HTTP 的差异&quot;">​</a></h2><h3 id="端口不同" tabindex="-1">端口不同 <a class="header-anchor" href="#端口不同" aria-label="Permalink to &quot;端口不同&quot;">​</a></h3><p>HTTP 的 URL 是由<code>http://</code> 起始与默认使用端口 80，而 HTTPS 的 URL 则是由 <code>https://</code> 起始与默认使用端口 443。</p><h3 id="安全性" tabindex="-1">安全性 <a class="header-anchor" href="#安全性" aria-label="Permalink to &quot;安全性&quot;">​</a></h3><p>HTTP 不是安全的，而且攻击者可以通过监听和中间人攻击等手段，获取网站帐户和敏感信息等。HTTPS 的设计可以防止前述攻击，在正确配置时是安全的。</p><h3 id="协议层" tabindex="-1">协议层 <a class="header-anchor" href="#协议层" aria-label="Permalink to &quot;协议层&quot;">​</a></h3><p>HTTP 协议和安全协议同属于应用层（<a href="./s_http_0-osi.html">OSI 模型</a>的最高层），具体来讲，<strong>安全协议工作在 HTTP 之下，传输层之上</strong>：</p><p>安全协议向运行 HTTP 的进程提供一个类似于 TCP 的套接字，供进程向其中注入报文，安全协议将报文加密并注入运输层套接字；或是从运输层获取加密报文，解密后交给对应的进程。</p><p>严格地讲，HTTPS 并不是一个单独的协议，而是对工作在一加密连接（TLS 或 SSL）上的常规 HTTP 协议的称呼。</p><p>HTTPS 报文中的任何东西都被加密，包括所有报头和荷载。除了可能的选择密文攻击（参见局限小节）之外，一个攻击者所能知道的只有在两者之间有一连接这一事实。</p><h3 id="服务器设置" tabindex="-1">服务器设置 <a class="header-anchor" href="#服务器设置" aria-label="Permalink to &quot;服务器设置&quot;">​</a></h3><p>要使一网络服务器准备好接受 HTTPS 连接，管理员必须创建一数字证书，并交由证书颁发机构签名以使浏览器接受。证书颁发机构会验证数字证书持有人和其声明的为同一人。浏览器通常都预装了证书颁发机构的证书，所以他们可以验证该签名。</p><h3 id="局限" tabindex="-1">局限 <a class="header-anchor" href="#局限" aria-label="Permalink to &quot;局限&quot;">​</a></h3><p>TLS 有两种策略：简单策略和交互策略。交互策略更为安全，但需要用户在他们的浏览器中安装个人的证书来进行认证。</p><p>不管使用了哪种策略，协议所能提供的保护总强烈地<code>依赖</code>于<code>浏览器的实现</code>和<code>服务器</code>软件所<code>支持的加密算法</code>。</p><p>HTTPS 并不能防止站点被网络爬虫抓取。在某些情形中，被加密资源的 URL 可仅通过截获请求和响应的大小推得，这就可使攻击者同时知道明文（公开的静态内容）和密文（被加密过的明文），从而使选择密文攻击成为可能。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noreferrer">维基百科https</a></li></ul>',26),c=[h];function l(i,d,p,s,T,n){return a(),t("div",null,c)}const S=e(r,[["render",l]]);export{_ as __pageData,S as default};
