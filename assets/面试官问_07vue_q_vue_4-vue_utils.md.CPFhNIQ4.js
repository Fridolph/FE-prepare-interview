import{_ as t,c as e,o as d,V as a}from"./chunks/framework.CMKosmpS.js";const v=JSON.parse('{"title":"工具","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/07vue/q_vue_4-vue_utils.md","filePath":"面试官问/07vue/q_vue_4-vue_utils.md","lastUpdated":1709101052000}'),o={name:"面试官问/07vue/q_vue_4-vue_utils.md"},r=a('<h1 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h1><h2 id="directive-指令" tabindex="-1">Directive - 指令 <a class="header-anchor" href="#directive-指令" aria-label="Permalink to &quot;Directive - 指令&quot;">​</a></h2><h3 id="自定义指令有哪些生命周期" tabindex="-1">自定义指令有哪些生命周期 <a class="header-anchor" href="#自定义指令有哪些生命周期" aria-label="Permalink to &quot;自定义指令有哪些生命周期&quot;">​</a></h3><h3 id="vue2-directive" tabindex="-1">Vue2 -&gt; directive <a class="header-anchor" href="#vue2-directive" aria-label="Permalink to &quot;Vue2 -&gt; directive&quot;">​</a></h3><details class="details custom-block"><summary>Vue2 自定义指令的生命周期，有 5 个事件钩子：</summary><ul><li><code>bind</code> 只调用一次，指令<code>第一次绑定到元素时</code>调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li><li><code>inserted</code> 被绑定元素<code>插入父节点</code>时调用（父节点存在即可调用，不必存在于 document 中）。</li><li><code>update</code> 被绑定元素所在的<code>模板更新时</code>调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li><li><code>componentUpdated</code> 被绑定元素所在模板<code>完成一次更新周期</code>时调用。</li><li><code>unbind</code> 只调用一次， <code>指令与元素解绑时</code>调用。</li></ul><p>钩子函数的参数 (包括 el，binding，vnode，oldVnode)：</p><ol><li>el: 指令所绑定的元素，可以用来直接操作 DOM 。</li><li>binding: 一个对象，包含以下属性：name: 指令名、value: 指令的绑定值、oldValue: 指令绑定的前一个值、expression: 绑定值的字符串形式、arg: 传给指令的参数、modifiers: 一个包含修饰符的对象。</li><li>vnode: Vue 编译生成的虚拟节点。</li><li>oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li></ol></details><h3 id="vue3-directive" tabindex="-1">Vue3 -&gt; directive <a class="header-anchor" href="#vue3-directive" aria-label="Permalink to &quot;Vue3 -&gt; directive&quot;">​</a></h3><details class="details custom-block"><summary>Vue3 自定义指令的生命周期，有 7 个事件钩子</summary><ul><li><code>created</code> 在绑定元素的 <code>attribute 前</code>或<code>事件监听器应用前</code>调用</li><li><code>beforeMount</code> 在元素<code>被插入到 DOM 前</code>调用</li><li><code>mounted</code> 在绑定元素的父组件及他自己的所有子节点都<code>挂载完成后</code>调用</li><li><code>beforeUpdate</code> 绑定元素的父组件更新前调用</li><li><code>updated</code> 在绑定元素的父组件及他自己的所有子节点都更新后调用</li><li><code>beforeUnmount</code> 绑定元素的父组件卸载前调用</li><li><code>unmounted</code> 绑定元素的父组件卸载后调用</li></ul></details><h2 id="vue-修饰符" tabindex="-1">Vue 修饰符 <a class="header-anchor" href="#vue-修饰符" aria-label="Permalink to &quot;Vue 修饰符&quot;">​</a></h2><h3 id="用过-sync-修饰符吗" tabindex="-1">用过 .sync 修饰符吗 <a class="header-anchor" href="#用过-sync-修饰符吗" aria-label="Permalink to &quot;用过 .sync 修饰符吗&quot;">​</a></h3><details class="details custom-block"><summary>是什么，怎么用</summary><ul><li>父组件 my-prop-name.sync 子组件 @update:my-prop-name 的模式来替代事件触发，实现父子组件间的双向绑定</li><li>一个组件可以多个属性用 .sync 修饰符，可以同时双向绑定多个“prop”</li><li>.sync 针对更多的是各种各样的状态，是状态的互相传递，是 status</li></ul></details><h3 id="事件修饰符" tabindex="-1">事件修饰符 <a class="header-anchor" href="#事件修饰符" aria-label="Permalink to &quot;事件修饰符&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td><code>.stop</code></td><td>阻止冒泡。</td></tr><tr><td><code>.prevent</code></td><td>阻止默认事件。</td></tr><tr><td><code>.capture</code></td><td>使用事件捕获模式。</td></tr><tr><td><code>.self</code></td><td>只在当前元素本身触发。</td></tr><tr><td><code>.once</code></td><td>只触发一次。</td></tr><tr><td><code>.passive</code></td><td>默认行为将会立即触发</td></tr></tbody></table></details><h3 id="按键修饰符" tabindex="-1">按键修饰符 <a class="header-anchor" href="#按键修饰符" aria-label="Permalink to &quot;按键修饰符&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td><code>.left</code></td><td>左键</td></tr><tr><td><code>.right</code></td><td>右键</td></tr><tr><td><code>.middle</code></td><td>滚轮</td></tr><tr><td><code>.enter</code></td><td>回车</td></tr><tr><td><code>.tab</code></td><td>制表键</td></tr><tr><td><code>.delete</code></td><td>捕获</td></tr><tr><td><code>.esc</code></td><td>返回</td></tr><tr><td><code>.space</code></td><td>空格</td></tr><tr><td><code>.up</code></td><td>上</td></tr><tr><td><code>.down</code></td><td>下</td></tr><tr><td><code>.ctrl</code></td><td>ctrl</td></tr><tr><td><code>.alt</code></td><td>alt</td></tr><tr><td><code>.shift</code></td><td>shift</td></tr><tr><td><code>.meta</code></td><td>meta</td></tr></tbody></table></details><h3 id="表单修饰符-v-model" tabindex="-1">表单修饰符 (v-model) <a class="header-anchor" href="#表单修饰符-v-model" aria-label="Permalink to &quot;表单修饰符 (v-model)&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td><code>.lazy</code></td><td>通过这个修饰符，转变为在 change 事件再同步</td></tr><tr><td><code>.number</code></td><td>自动将用户的输入值转化为数值类型</td></tr><tr><td><code>.trim</code></td><td>自动过滤用户输入的首尾空格</td></tr></tbody></table></details><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><h3 id="vue3常用工具函数" tabindex="-1">vue3常用工具函数 <a class="header-anchor" href="#vue3常用工具函数" aria-label="Permalink to &quot;vue3常用工具函数&quot;">​</a></h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>isRef()</code></td><td>检查某个值是否为 ref</td></tr><tr><td><code>unref()</code></td><td>如果参数是 ref，则返回内部值，否则返回参数本身</td></tr><tr><td><code>toRef()</code></td><td>可以将值、refs 或 getters 规范化为 refs；也可以基于响应式对象上的一个属性，创建一个对应的 ref</td></tr><tr><td><code>toValue()</code></td><td>将值、refs 或 getters 规范化为值。这与 unref() 类似</td></tr><tr><td><code>toRefs()</code></td><td>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。解构不会丢失响应性</td></tr><tr><td><code>isProxy()</code></td><td>检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理</td></tr><tr><td><code>isReactive()</code></td><td>检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理</td></tr><tr><td><code>isReadonly()</code></td><td>检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。</td></tr></tbody></table><h3 id="setup-中如何获得组件实例" tabindex="-1">setup 中如何获得组件实例 <a class="header-anchor" href="#setup-中如何获得组件实例" aria-label="Permalink to &quot;setup 中如何获得组件实例&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>在 setup 函数中，你可以使用 <code>getCurrentInstance()</code> 方法来获取组件实例。getCurrentInstance() 方法返回一个对象，该对象包含了组件实例以及其他相关信息。</p><blockquote><p>需要注意的是，getCurrentInstance() 方法只能在 setup 函数中使用，而不能在组件的生命周期方法（如 created、mounted 等方法）中使用。另外，需要注意的是，如果在 setup 函数返回之前访问了 instance 对象，那么它可能是 undefined ，因此我们需要对其进行处理。</p></blockquote></details>',21),c=[r];function l(i,s,u,n,h,m){return d(),e("div",null,c)}const p=t(o,[["render",l]]);export{v as __pageData,p as default};
