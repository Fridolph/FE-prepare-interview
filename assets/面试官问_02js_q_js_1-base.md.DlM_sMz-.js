import{_ as t,c as l,o as a,V as e}from"./chunks/framework.CMKosmpS.js";const f=JSON.parse('{"title":"下面为变量类型相关常考察点","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/02js/q_js_1-base.md","filePath":"面试官问/02js/q_js_1-base.md","lastUpdated":1723977842000}'),i={name:"面试官问/02js/q_js_1-base.md"},o=e('<h1 id="下面为变量类型相关常考察点" tabindex="-1">下面为变量类型相关常考察点 <a class="header-anchor" href="#下面为变量类型相关常考察点" aria-label="Permalink to &quot;下面为变量类型相关常考察点&quot;">​</a></h1><p>若有陌生或不清楚的可再到 <a href="./../../直击概念/02js/s_js_1-base.html">直击概念 - 变量</a> 回顾</p><h2 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h2><h3 id="js-有多少种数据类型" tabindex="-1">JS 有多少种数据类型 <a class="header-anchor" href="#js-有多少种数据类型" aria-label="Permalink to &quot;JS 有多少种数据类型&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>基本类型 7 <ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li><li>Symbol</li><li>BigInt</li></ul></li><li>引用类型：Object <ul><li>Array、Function、Date、RegExp、Error 等</li></ul></li></ul></details><h3 id="数据类型的判断方式" tabindex="-1">数据类型的判断方式 <a class="header-anchor" href="#数据类型的判断方式" aria-label="Permalink to &quot;数据类型的判断方式&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ol><li>typeof 操作数的类型，只能识别基础数据类型和引用类型</li></ol><p>特别注意：</p><ul><li>tyoeof null === &#39;object&#39;</li><li>tyoeof NaN === &#39;number&#39;</li><li>tyoeof document.all === &#39;undefined&#39; 不是浏览器标准</li></ul><ol start="2"><li>constructor 指向创建梳理对象的构造函数（作为辅助方法来判断）</li></ol><p>注意事项：</p><ul><li>null 和 undefined 没有 constructor 属性</li><li>constructor 属性是可修改的</li></ul><ol start="3"><li>instanceof 判断一个实例是否属于某个类。原型链查找</li></ol><p>注意事项：右操作数必须是函数或者 class</p><ol start="4"><li>isPrototypeOf 是否出现在实力对象的原型链上</li></ol><p>注意：能正常返回值的情况，基本等同 instanceof</p><ol start="5"><li>Object.prototype.toString</li></ol><p>通过函数的动态 this 特性，返回其数据类型 <code>[object Date]</code></p><ol start="6"><li>鸭子类型检测</li></ol><p>检查自身，属性的类型或者执行结果的类型，例如 Promise（候选方法）</p><ol start="7"><li>Symbol.toStringTag</li></ol><p>Object.prototype.toString 会读取该值，需自定义类型，要注意兼容性（ES6 后新增高级特性）</p><ol start="8"><li>等比较：与某个固定值进行比较</li></ol><p>使用场景 undefined、window、document、null 等</p></details><h3 id="let、const-和-var-的区别" tabindex="-1">let、const 和 var 的区别 <a class="header-anchor" href="#let、const-和-var-的区别" aria-label="Permalink to &quot;let、const 和 var 的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><table><thead><tr><th>特性</th><th>let</th><th>const</th><th>var</th></tr></thead><tbody><tr><td>变量提升</td><td>无，暂时性死区</td><td>无，暂时性死区</td><td>存在变量提升</td></tr><tr><td>立即赋值</td><td>不需</td><td>需要</td><td>不需</td></tr><tr><td>可修改</td><td>可修改</td><td>基础类型不可修改，引用类型赋值后可修改</td><td>可修改</td></tr></tbody></table></details><h2 id="判断" tabindex="-1">判断 <a class="header-anchor" href="#判断" aria-label="Permalink to &quot;判断&quot;">​</a></h2><h3 id="typeof-的用法" tabindex="-1">typeof 的用法 <a class="header-anchor" href="#typeof-的用法" aria-label="Permalink to &quot;typeof 的用法&quot;">​</a></h3><details class="details custom-block"><summary>点击提示</summary><p><strong>typeof</strong></p><ul><li>判断所有值类型：number、string、boolean、undefined、symbol、bigint</li><li>能识别函数 function</li><li>判断是否为引用类型 （但不能细分）</li><li>null 会被判断为 object</li></ul></details><h3 id="instanceof-的用法" tabindex="-1">instanceof 的用法 <a class="header-anchor" href="#instanceof-的用法" aria-label="Permalink to &quot;instanceof 的用法&quot;">​</a></h3><details class="details custom-block"><summary>点击提示</summary><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p></details><h3 id="typeof-与-instanceof-的区别" tabindex="-1">typeof 与 instanceof 的区别 <a class="header-anchor" href="#typeof-与-instanceof-的区别" aria-label="Permalink to &quot;typeof 与 instanceof 的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><table><thead><tr><th>特性</th><th>typeof</th><th>instanceof</th></tr></thead><tbody><tr><td>返回类型</td><td>返回一个变量的基本类型</td><td>返回的是一个布尔值</td></tr><tr><td>判断范围</td><td>基础数据类型(null 除外)和 function</td><td>准确地判断复杂引用数据类型</td></tr></tbody></table><ul><li><code>返回结果类型不同</code>：typeof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值</li><li><code>判断范围不同</code>：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</li></ul></details><h3 id="object-is-与比较操作符-、-的区别" tabindex="-1">Object.is() 与比较操作符 “===”、“==” 的区别 <a class="header-anchor" href="#object-is-与比较操作符-、-的区别" aria-label="Permalink to &quot;Object.is() 与比较操作符 “===”、“==” 的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行<code>强制类型转化</code>后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，<code>不会做强制类型准换</code>，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它<code>处理了一些特殊的情况</code>，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul></details><h3 id="对象转为原始数据类型的值" tabindex="-1">对象转为原始数据类型的值 <a class="header-anchor" href="#对象转为原始数据类型的值" aria-label="Permalink to &quot;对象转为原始数据类型的值&quot;">​</a></h3><p>隐式转换的要点：</p><ul><li>Symbol.ToPrimitive</li><li>Object.ptototype.valueOf</li><li>Object.ptototype.toString</li></ul><details class="details custom-block"><summary>详细信息</summary><p>[] 的原始值：</p><ul><li><code>typeof [][Symbol.ToPrimitive]</code> -&gt; undefined</li><li><code>[].valueOf()</code> -&gt; []</li><li><code>[].toString()</code> -&gt; &#39;&#39;</li></ul><p>{} 的原始值：</p><ul><li><code>typeof {}[Symbol.ToPrimitive]</code> -&gt; undefined</li><li><code>{}</code>.valueOf() -&gt; {}</li><li><code>{}</code>.toString() -&gt; &#39;[object Object]&#39;</li></ul><p>所以：</p><p>[] + [] = &#39;&#39; [] + {} = &#39;[object Object]&#39;</p><p>{} + [] = 0 -&gt; {}; + [] -&gt; + &#39;&#39; -&gt; 0 {} + {} = NaN -&gt; {}; + {} -&gt; + &#39;[object Object]&#39; -&gt; NaN</p></details><h3 id="操作符的强制类型转换规则" tabindex="-1">== 操作符的强制类型转换规则 <a class="header-anchor" href="#操作符的强制类型转换规则" aria-label="Permalink to &quot;== 操作符的强制类型转换规则&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>如果比较的是基本数据类型，直接比较值是否相等</li><li>如果比较的是对象，则比较其内部值是否相等</li><li>如果比较的是 null 和 undefined，则返回 true</li><li>如果比较的是字符串和数字，则将字符串转换为数字再进行比较</li><li>如果比较的是布尔值和数字，则将布尔值转换为数字再进行比较</li></ul></details><h3 id="对于-和-比较符" tabindex="-1">对于 &lt; 和 &gt; 比较符 <a class="header-anchor" href="#对于-和-比较符" aria-label="Permalink to &quot;对于 &lt; 和 &gt; 比较符&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>如果两边都是字符串，则比较字母表顺序，<code>&#39;a&#39; &lt; &#39;b&#39; -&gt; true</code></li><li>其他情况下，转换为数字再比较 <code>&#39;12&#39; &lt; 4 -&gt; false</code>，<code>false &gt; -1 -&gt; true</code></li></ul></details><h2 id="运算" tabindex="-1">运算 <a class="header-anchor" href="#运算" aria-label="Permalink to &quot;运算&quot;">​</a></h2><h3 id="为什么-0-1-0-2-0-3-如何让其相等" tabindex="-1">为什么 0.1+0.2 ! == 0.3，如何让其相等 <a class="header-anchor" href="#为什么-0-1-0-2-0-3-如何让其相等" aria-label="Permalink to &quot;为什么 0.1+0.2 ! == 0.3，如何让其相等&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>计算机是通过二进制的方式存储数据的，所以计算机计算 0.1+0.2 的时候，实际上是计算的两个数的二进制的和。0.1 的二进制是 0.0001100110011001100...（1100 循环），0.2 的二进制是：0.00110011001100...（1100 循环），这两个数的二进制都是无限循环的数。</p></details><h2 id="数组相关" tabindex="-1">数组相关 <a class="header-anchor" href="#数组相关" aria-label="Permalink to &quot;数组相关&quot;">​</a></h2><h3 id="类数组" tabindex="-1">类数组 <a class="header-anchor" href="#类数组" aria-label="Permalink to &quot;类数组&quot;">​</a></h3><p>是一个普通对象，有 length 属性和从零开始索引的属性，但是没有数组的内置方法</p><ul><li>arguments 对象</li><li>DOM 相关列表</li></ul><p>类数组如何转为数组：</p><ul><li>JS API ： slice concat 等</li><li>Array.from</li><li>Array.apply</li><li>复制 与 遍历</li></ul><h3 id="创建数组的几种方式" tabindex="-1">创建数组的几种方式 <a class="header-anchor" href="#创建数组的几种方式" aria-label="Permalink to &quot;创建数组的几种方式&quot;">​</a></h3><ul><li>数组对象字面量 new Array</li><li>Array.from (ES6)</li><li>Array.of (ES6)</li></ul><p>批量创建数据</p><ol><li>批量制造数据 for</li><li>运用 map 循环</li><li>Array.fill 填充数据</li><li>Array.from 初始化函数返回数据</li><li>数组去重 Set</li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7227787460968415289" target="_blank" rel="noreferrer">前端（HTML+CSS+JS+打包+环境+网络）2023</a></li></ul>',41),r=[o];function s(d,c,n,u,h,m){return a(),l("div",null,r)}const p=t(i,[["render",s]]);export{f as __pageData,p as default};
