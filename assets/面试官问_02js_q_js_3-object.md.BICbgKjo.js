import{_ as s,E as l,c as i,J as t,V as a,o as n}from"./chunks/framework.CMKosmpS.js";const m=JSON.parse('{"title":"面向对象","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/02js/q_js_3-object.md","filePath":"面试官问/02js/q_js_3-object.md","lastUpdated":1723977842000}'),r={name:"面试官问/02js/q_js_3-object.md"},o=a('<h1 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to &quot;面向对象&quot;">​</a></h1><p>回顾 <a href="./../../直击概念/02js/s_js_3-object.html">直击概念 - 变量</a></p><h2 id="属性基础" tabindex="-1">属性基础 <a class="header-anchor" href="#属性基础" aria-label="Permalink to &quot;属性基础&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><ul><li>静态属性，例如 Object.assign</li><li>原型属性，例如 Object.prototype.toString</li><li>实例属性</li></ul><p>属性描述符：Object.defineProperty</p><ul><li>configurable 可配置</li><li>enumerable 是否可枚举</li><li>value 值</li><li>writable 可修改</li><li>get 访问器函数</li><li>set 修改器函数</li></ul><p>缺点：无法监听数组的变化； 只能劫持对象属性，因为需对每个对象每个属性进行遍历，若属性也为对象需要进行递归（Vue2）</p><p>对象不可扩展 Object.preventExtentions</p><p>对象的封闭 Object.seal 阻止对象添加新属性，属性标志为不可配置</p><p>对象的冻结 Object.freeze 属性标志为不可配置、不可写、不可枚举</p></details><h2 id="如何访问对象原型" tabindex="-1">如何访问对象原型 <a class="header-anchor" href="#如何访问对象原型" aria-label="Permalink to &quot;如何访问对象原型&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><ol><li>通过 prototype ：对象内的显式属性，原型形成原型链</li><li>通过 <code>__proto__</code> ：对象内的隐式属性，指向构造函数的原型对象</li><li>通过 Object.getPrototypeOf、Refelect.getPrototypeOf ：返回对象的原型，内部先 toObject 转换</li><li>通过 Object.setPrototypeOf ：设定对象的原型</li><li>原型的尽头为 null</li></ol></details><h2 id="类与继承" tabindex="-1">类与继承 <a class="header-anchor" href="#类与继承" aria-label="Permalink to &quot;类与继承&quot;">​</a></h2><h3 id="说一下原型链" tabindex="-1">说一下原型链 <a class="header-anchor" href="#说一下原型链" aria-label="Permalink to &quot;说一下原型链&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>每个对象都有属性 prototype，一个隐式原型叫 <code>__proto__</code>，它指向其<code>构造函数的原型对象</code></li><li>当查找某个属性或方法时，先从自身上查找，没有找到会沿着 <code>__proto__</code> 找到构造函数（constructor）的原型对象（prototype），仍然没有找到会继续沿着 <code>__proto__</code> 向上查找到它构造函数原型对象的原型对象</li><li>直到找到顶级对象 object 为 null，由此形成的链条为原型链</li></ul></details>',9),d=a('<details class="details custom-block"><summary>引用类型四个特性</summary><ul><li>引用类型，都具有对象特性，即可自由扩展属性</li><li>引用类型，都有一个隐式原型，即 <code>__proto__</code>，属性值为一个普通对象</li><li>引用类型，隐式原型的属性值指向它构造函数 <code>Constructor</code> 的显式原型 prototype 属性值</li><li>当查找一个对象某个属性时，若对象本身没有该属性，会去找它隐式原型 <code>__proto__</code> 中寻找</li><li>若还是没找到会继续在它构造函数的显式原型 <code>prototype</code> 中寻找，直至找到或 <code>__proto__</code> 为 null 为止，由此形成原型链</li></ul></details><h2 id="对象隐式转换规则" tabindex="-1">对象隐式转换规则 <a class="header-anchor" href="#对象隐式转换规则" aria-label="Permalink to &quot;对象隐式转换规则&quot;">​</a></h2><ol><li>如果 <code>[Symbol.toPrimitive]</code> 方法存在，有限调用，无视 valueOf 和 toString 方法</li><li>否则，若期望为 string 先调用 obj.toString() 如果返回不是原始值，继续调用 obj.valueOf()</li><li>否则，若期望是 number 或 default ，先调用 obj.valueOf 如果返回值不是原始值，继续调用 obj.toString</li></ol><h2 id="什么是浅拷贝" tabindex="-1">什么是浅拷贝 <a class="header-anchor" href="#什么是浅拷贝" aria-label="Permalink to &quot;什么是浅拷贝&quot;">​</a></h2><p>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以<code>如果其中一个对象改变了这个地址，就会影响到另一个对象</code>。</p><details class="details custom-block"><summary>实现浅拷贝的几种方式</summary><ol><li><code>Object.assign()</code></li><li><code>lodash</code>的 _.clone 方法</li><li>ES6 展开运算符 <code>...</code></li><li>Array.prototype.<code>concat()</code></li><li>Array.prototype.<code>slice()</code></li></ol></details><h2 id="什么是深拷贝" tabindex="-1">什么是深拷贝 <a class="header-anchor" href="#什么是深拷贝" aria-label="Permalink to &quot;什么是深拷贝&quot;">​</a></h2><p>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象，且<code>修改新对象不会影响原对象</code>。</p><h2 id="赋值和深浅拷贝的区别" tabindex="-1">赋值和深浅拷贝的区别 <a class="header-anchor" href="#赋值和深浅拷贝的区别" aria-label="Permalink to &quot;赋值和深浅拷贝的区别&quot;">​</a></h2>',9),c=a(`<details class="details custom-block"><summary>实现深拷贝的几种方式</summary><ol><li>JSON.parse(JSON.stringify()) <code>缺点是不能处理函数和正则</code></li><li><code>lodash</code>的 <code>_.cloneDeep</code> 方法</li><li><code>jQuery.extend()</code> 方法</li><li>手写递归方法 - 见 <a href="./../../编写代码/02js/c_js_2-deepcopy/c_js_2-deepcopy.html">deepCopy</a></li><li>消息通讯：BroadcastChannel、window.postMessage、Shared Worker、Message Channel 进行深拷贝</li></ol><p>注：用消息通讯方法，循环引用对象不能复制，如 windows，不支持函数，同步方法会变成异步</p></details><h2 id="对象的属性遍历" tabindex="-1">对象的属性遍历 <a class="header-anchor" href="#对象的属性遍历" aria-label="Permalink to &quot;对象的属性遍历&quot;">​</a></h2><ul><li>普通属性：下面的常规和排序属性都属于普通属性</li><li>不可枚举属性</li><li>原型属性</li><li>Symbol 属性</li><li>静态属性</li></ul><details class="details custom-block"><summary>详细信息</summary><p>注意：遍历属性拿到 key 的顺序与添加的顺序不同（但有规律）</p><ul><li>常规属性：字符串作为作为键的属性</li><li>排序属性：数字作为键的属性</li><li>键被遍历的顺序规律：常规属性按添加顺序，而排序属性按索引值大小升序排序</li></ul><p>相关方法：</p><table><thead><tr><th style="text-align:center;">方法名</th><th style="text-align:center;">普通属性</th><th style="text-align:center;">不可枚举属性</th><th style="text-align:center;">Symbol 属性</th><th style="text-align:center;">原型属性</th></tr></thead><tbody><tr><td style="text-align:center;">for...in</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">Object.keys()</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">Object.getOwnPropertyNames()</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">Object.getOwnPropertySymbols()</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">Reflect.ownKeys()</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td></tr></tbody></table></details><h3 id="如何获取对象的全部静态属性" tabindex="-1">如何获取对象的全部静态属性： <a class="header-anchor" href="#如何获取对象的全部静态属性" aria-label="Permalink to &quot;如何获取对象的全部静态属性：&quot;">​</a></h3><p><code>Reflect.ownKeys = Object.getOwnPropertyNames + Object.getOwnPropertySymbols</code></p><h3 id="如何获取原型上的所有属性" tabindex="-1">如何获取原型上的所有属性 <a class="header-anchor" href="#如何获取原型上的所有属性" aria-label="Permalink to &quot;如何获取原型上的所有属性&quot;">​</a></h3><p>for in + 递归 + 剔除内置属性</p><h3 id="如何获取所有不可枚举属性" tabindex="-1">如何获取所有不可枚举属性 <a class="header-anchor" href="#如何获取所有不可枚举属性" aria-label="Permalink to &quot;如何获取所有不可枚举属性&quot;">​</a></h3><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取原型对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> keys</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ownKeys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keys.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOwnPropertyDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, key).enumerable</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><p>浅拷贝与深拷贝 <a href="https://juejin.cn/post/6844904197595332622" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904197595332622</a></p></li><li><p>深拷贝的终极探索 <a href="https://segmentfault.com/a/1190000016672263" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000016672263</a></p></li><li><p>How to deep clone a JavaScript object<a href="https://flaviocopes.com/how-to-clone-javascript-object/" target="_blank" rel="noreferrer">https://flaviocopes.com/how-to-clone-javascript-object/</a></p></li></ul>`,12);function h(p,k,y,b,u,_){const e=l("Image");return n(),i("div",null,[o,t(e,{src:"/02js/prototype-chain.png",alt:"原型链"}),d,t(e,{src:"/02js/clone1.png",alt:"shadowCopy"}),t(e,{src:"/02js/clone2.png",alt:"deepCopy"}),c])}const j=s(r,[["render",h]]);export{m as __pageData,j as default};
