import{_ as o,E as a,c as s,m as e,J as r,a as l,V as t,o as u}from"./chunks/framework.VAJu91au.js";const T=JSON.parse('{"title":"Vue3 核心","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/07vue/q_vue_1-vue3.md","filePath":"面试官问/07vue/q_vue_1-vue3.md","lastUpdated":1709101052000}'),d={name:"面试官问/07vue/q_vue_1-vue3.md"},n=e("h1",{id:"vue3-核心",tabindex:"-1"},[l("Vue3 核心 "),e("a",{class:"header-anchor",href:"#vue3-核心","aria-label":'Permalink to "Vue3 核心"'},"​")],-1),c=e("blockquote",null,[e("p",null,"很多资料、文章很多说的是 Vue2，为了避免混淆，这个单独拎一个出来。")],-1),p=e("p",null,"Vue3 是以后的大趋势，除了核心响应式原理外，其他部分内容整理都以 Vue3 为主了。",-1),m=e("h2",{id:"vue3-的响应式原理",tabindex:"-1"},[l("Vue3 的响应式原理 "),e("a",{class:"header-anchor",href:"#vue3-的响应式原理","aria-label":'Permalink to "Vue3 的响应式原理"'},"​")],-1),_=e("p",null,"Proxy 实现的响应式原理与 Vue2 的实现原理相同，实现方式大同小异：",-1),h={class:"details custom-block"},V=t("<summary>详细信息</summary><p>当一个 Vue 实例创建时，Vue 会遍历 data 中的属性， 使用 <code>Proxy</code>将它们转为 <code>getter/setter</code>，并且在<code>内部追踪相关依赖</code>，<strong>在属性被访问和修改时通知变化</strong>。</p><p>每个组件实例都有相应的 watcher 程序实例，它会在组 件渲染的过程中把属性记录为依赖 Dependency，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p><ul><li>get 收集依赖</li><li>Set、delete 等触发依赖</li><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑</li></ul>",4),f=t('<h2 id="vue3-0-为什么要用-proxy" tabindex="-1">Vue3.0 为什么要用 proxy？ <a class="header-anchor" href="#vue3-0-为什么要用-proxy" aria-label="Permalink to &quot;Vue3.0 为什么要用 proxy？&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><ol><li>Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li><li>Object.defineProperty <code>只能劫持对象的属性</code>，从而需要对每个对象，每个属性进行遍历，如果，<code>属性值是对象，还需要深度遍历</code>。Proxy 可以劫持整个对象，并返回一个新的对象</li><li>Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性（解决 1）</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化</li></ol></details><h2 id="vue-2-与-3-的差异" tabindex="-1">Vue 2 与 3 的差异 <a class="header-anchor" href="#vue-2-与-3-的差异" aria-label="Permalink to &quot;Vue 2 与 3 的差异&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><p><strong>一、响应式原理</strong></p><ul><li>Vue2 响应式原理基于 <code>Object.defineProperty</code></li><li>Vue3 响应式原理基于 <code>Proxy</code></li></ul><p><strong>二、API 不同</strong></p><ul><li>Vue2 使用 Options 选项式</li><li>Vue3 推荐使用 Composition API 组合式</li></ul><p><strong>三、定义响应式数据不同</strong></p><ul><li>vue2 在 data 里的数据都是响应式的</li><li>vue3 使用 ref、reactive，ref 取值需要用 .value</li></ul><p><strong>四、生命周期不同</strong></p><ul><li>Vue2 <ul><li>beforeCreate、created</li><li>beforeMount、mounted</li><li>beforeUpdate、updated</li><li>beforeDestroy、destroyed</li></ul></li><li>Vue3 <ul><li>setup</li><li>onBeforeMount、onMounted</li><li>onBeforeUpdate、onUpdated</li><li>onBeforeUnmount、onUnmounted</li></ul></li></ul><p><strong>五、获取组件实例方法不同</strong></p><ul><li>Vue2 ref 属性，通过 this.$refs 获取到实例</li><li>Vue3 中不能直接使用 $refs ，需要用 ref 定义一个响应式数据并设置 null，且组件要设置 ref 的属性</li><li>Vue3 获取子组件实例后，父组件只能使用子组件暴露 defineExpose 出来的方法或变量</li></ul><p><strong>六、组件传值（通信）</strong></p><ul><li>Vue2 父组件 v-bind，子组件 props 拿到</li><li>Vue3 setup(props, context)来接收；用 ts + setup，还需使用 defineProps 和 defineEmits 来定义 props 和 emit</li></ul><p>七、其他（关联不大都放一起说了）</p><ul><li>Vue3 可以没有根节点了， <code>&lt;&gt; &lt;/&gt;</code></li><li>去掉了$Bus，推荐使用 <code>provide</code> 和 <code>inject</code></li><li>Vue3 Diff 算法优化：vue2 是全量 Diff，vue3 新增静态标记</li><li>新增 watchEffect，自动搜集依赖</li><li>新增 Teleport 组件：可以把组件内的一部分传到该组件的 DOM 结构外层的位置去</li><li>新增 Suspense 组件：在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态</li></ul><p>相对优势：</p><p>Vue2 面对的问题：</p><ul><li>代码架构：整体架构比较粗糙</li><li>性能优化空间：Vue2 编译器能力有限</li><li>API 在大型项目中的可维护性：option API 在大型项目中维护遇到瓶颈</li><li>浏览器版本的限制：支持 IE9，不可能一直支持那么旧的浏览器</li></ul><p>Vue3 比较成功的决定：</p><ul><li>拥抱 TypeScript，Vue 本身的可维护性也大大提升</li><li>坚持 Composition API。<code>setup</code> 大大提升开发体验，提升了可重构性和可维护性</li><li>逻辑复用：Composition API 带来了 VueUse 等的工具库</li><li>Vite，快快快! esbuild，esmodule，越来越完善</li><li>Vue3 新文档对现有内容进行了大量的重写和代码调整</li><li>Volar：大大提升 Vue SFC 的 TypeScript 支持</li></ul></details><h2 id="proxy-只代理对象第一层-vue3-如何处理" tabindex="-1">Proxy 只代理对象第一层，Vue3 如何处理 <a class="header-anchor" href="#proxy-只代理对象第一层-vue3-如何处理" aria-label="Permalink to &quot;Proxy 只代理对象第一层，Vue3 如何处理&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><p>判断当前 <code>Reflect.get</code> 的返回值是否为 Object，如果是则再通过 <code>reactive</code> 方法做代理，这样就实现了深度观测。</p></details><h2 id="监测数组的时候可能触发多次-get-set-那么如何防止触发多次" tabindex="-1">监测数组的时候可能触发多次 get/set，那么如何防止触发多次 <a class="header-anchor" href="#监测数组的时候可能触发多次-get-set-那么如何防止触发多次" aria-label="Permalink to &quot;监测数组的时候可能触发多次 get/set，那么如何防止触发多次&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><p>我们可以<strong>判断 key 是否为当前被代理对象 target 自身属性</strong>，也可以<strong>判断旧值与新值是否相等</strong>，只有满足以上两个条件之一时，才有可能执行 trigger</p></details><h2 id="如何看待-composition-api" tabindex="-1">如何看待 Composition API <a class="header-anchor" href="#如何看待-composition-api" aria-label="Permalink to &quot;如何看待 Composition API&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><ul><li>Vue3 新引入组件编写方式，允许以函数形式编写代码</li><li>提供模块化（按需加载）、类型推断等功能</li><li>更好组织代码，逻辑复用，提高可维护性和可扩展性</li></ul></details><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/21mt8zBjOqdhKfRO8SPLHg" target="_blank" rel="noreferrer">Vue2 和 Vue3 的差异</a></li></ul>',12);function g(y,P,b,v,x,q){const i=a("Image");return u(),s("div",null,[n,c,p,m,_,e("details",h,[V,r(i,{src:"/07vue/reactive.jpg",alt:"Vue响应式原理"})]),f])}const I=o(d,[["render",g]]);export{T as __pageData,I as default};
