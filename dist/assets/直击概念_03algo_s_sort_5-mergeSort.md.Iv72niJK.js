import{_ as r,E as o,c as t,J as l,V as e,o as n}from"./chunks/framework.CMKosmpS.js";const f=JSON.parse('{"title":"归并排序 Merge Sort","description":"","frontmatter":{},"headers":[],"relativePath":"直击概念/03algo/s_sort_5-mergeSort.md","filePath":"直击概念/03algo/s_sort_5-mergeSort.md","lastUpdated":1708674619000}'),i={name:"直击概念/03algo/s_sort_5-mergeSort.md"},_=e('<h1 id="归并排序-merge-sort" tabindex="-1">归并排序 Merge Sort <a class="header-anchor" href="#归并排序-merge-sort" aria-label="Permalink to &quot;归并排序 Merge Sort&quot;">​</a></h1><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O（n log n）的时间复杂度。代价是需要额外的内存空间。</p></blockquote><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用<code>分治法</code>（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。</p><h2 id="算法描述" tabindex="-1">算法描述 <a class="header-anchor" href="#算法描述" aria-label="Permalink to &quot;算法描述&quot;">​</a></h2><p>具体算法描述如下：</p><ol><li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol>',7),s=e('<h2 id="算法实现" tabindex="-1">算法实现 <a class="header-anchor" href="#算法实现" aria-label="Permalink to &quot;算法实现&quot;">​</a></h2><p><a href="./../../编写代码/03algo/c_sort_5-mergeSort/c_sort_5-mergeSort.html">归并排序实现</a></p><h2 id="算法分析" tabindex="-1">算法分析 <a class="header-anchor" href="#算法分析" aria-label="Permalink to &quot;算法分析&quot;">​</a></h2><ul><li>最佳情况：T(n) = O(n)</li><li>最差情况：T(n) = O(nlogn)</li><li>平均情况：T(n) = O(nlogn)</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6844903444365443080" target="_blank" rel="noreferrer">十大经典排序算法总结（JavaScript 描述）</a></li></ul>',6);function c(h,d,m,g,p,u){const a=o("Image");return n(),t("div",null,[_,l(a,{alt:"归并排序动图演示",src:"/03algo/mergeSort.gif"}),s])}const b=r(i,[["render",c]]);export{f as __pageData,b as default};
