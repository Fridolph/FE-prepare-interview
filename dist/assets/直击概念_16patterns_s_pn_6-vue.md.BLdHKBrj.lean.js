import{_ as l,E as e,c as t,m as s,a as n,t as h,J as p,V as i,o as k}from"./chunks/framework.CMKosmpS.js";const I=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"直击概念/16patterns/s_pn_6-vue.md","filePath":"直击概念/16patterns/s_pn_6-vue.md","lastUpdated":1723566143000}'),r={name:"直击概念/16patterns/s_pn_6-vue.md"},E=i("",11),d=s("code",null,"<h1>",-1),g=i("",6),c=i("",18),o=s("p",null,"尽管这个组件很小，但里面的逻辑已经错综交织。有些部分专门用于计数器的功能，而其他部分则涉及宽度逻辑。随着组件的增长，在组件内部组织和定位相关逻辑将变得更加具有挑战性。",-1),y=s("p",null,"为了应对这些挑战，Vue 团队在 Vue3 中引入了 Composition API。",-1),u=s("p",null,"简而言之，Composition API 提供了一种更灵活、更直观的方式来组织和管理 Vue 组件内部的逻辑。它允许开发者组合不同的函数和 API 来构建所需的功能，而不是局限于传统的 Options API 方法。这有助于将组件逻辑分解为更小、更易管理的块，使其更容易理解和维护。",-1),b=s("p",null,"组件（Composables）",-1),m=s("p",null,"基于我们之前的代码示例，可能仍有人会疑惑 setup()函数在开发过程中提供了哪些优势，因为看起来它仅仅要求我们在一个函数内部声明组件选项。",-1),F=s("p",null,"采用组合式 API 的绝佳好处之一是能够在组件之间提取和重用共享逻辑。这是由我们可简单声明使用 Vue 全局可用的组合式函数的函数这一事实驱动的，我们的函数可以很容易地在多个组件中使用以实现相同的结果。",-1),A=s("p",null,"通过使用 Composition API 设置中的可组合函数，我们能够把应用程序的上下文拆分成更小、可重用的部分，从而使逻辑分离。让我们可视化一下我们刚刚做出的更改，与初始的 Options API 示例组件相比。",-1),C=i("",21);function D(v,_,B,f,P,q){const a=e("Image");return k(),t("div",null,[E,s("p",null,[n("该组件定义了一个 props 属性，它接受一个名为 name 的单一属性。Props 是一种从父组件向子组件传递数据的方式。模板属性定义了组件的 HTML 模板。在这种情况下，它包含一个"),d,n("标题标签，显示文本“Hello，my name is”，后面跟着使用 Vue 的双大括号语法渲染的 name 属性的值"),s("code",null,h(),1),n("。")]),g,p(a,{src:"/16patterns/vue1.png",alt:"拆分组件"}),c,p(a,{src:"/16patterns/optionsApi.png",alt:"optionsApi"}),o,y,u,b,m,F,A,p(a,{src:"/16patterns/compositionApi.png",alt:"compositionApi"}),C])}const T=l(r,[["render",D]]);export{I as __pageData,T as default};
