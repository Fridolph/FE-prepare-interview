import{_ as t,E as i,c as s,m as o,J as l,V as e,o as d}from"./chunks/framework.GzbH9VPN.js";const V=JSON.parse('{"title":"Vue 核心","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/07vue/q_vue_0-vue_base.md","filePath":"面试官问/07vue/q_vue_0-vue_base.md","lastUpdated":1708509699000}'),c={name:"面试官问/07vue/q_vue_0-vue_base.md"},r=e('<h1 id="vue-核心" tabindex="-1">Vue 核心 <a class="header-anchor" href="#vue-核心" aria-label="Permalink to &quot;Vue 核心&quot;">​</a></h1><blockquote><p>这里都是 Vue2 相关内容，毕竟还有很多公司在问 Vue 问题时是针对 Vue2（仅个人经历）建议还是先从 Vue3 来说</p></blockquote><h2 id="响应式-reactive" tabindex="-1">响应式 Reactive <a class="header-anchor" href="#响应式-reactive" aria-label="Permalink to &quot;响应式 Reactive&quot;">​</a></h2><h3 id="vue-的响应式原理" tabindex="-1">Vue 的响应式原理 <a class="header-anchor" href="#vue-的响应式原理" aria-label="Permalink to &quot;Vue 的响应式原理&quot;">​</a></h3>',4),n={class:"details custom-block"},u=e("<summary>详细信息</summary><p>Vue2 采用数据劫持结合发布订阅模式（PubSub 模式）的方式，通过 <code>Object.defineProperty</code> 来劫持各个属性的 setter、getter，在<code>数据变动时</code>发布消息给订阅者，<code>触发相应的监听回调</code>。</p><p>当把一个 JS 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 <code>Object.defineProperty</code> 将它们转为 <code>getter/setter</code>（用户不可见）。Vue 在内部进行<code>追踪依赖</code>，<code>在属性被访问和修改时通知变化</code>。</p><p>Vue 的数据双向绑定整合了 Observer，Compile 和 Watcher 三者，通过 <code>Observer 来监听自己的 model 的数据变化</code>，通过 <code>Compile 来解析编译模板指令</code>，最终利用 <code>Watcher 达到数据变化 -&gt; 视图更新</code>（搭起 Observer 和 Compile 之间的通信桥梁）。</p><blockquote><p>Vue3.x 放弃了 Object.defineProperty ，使用 ES6 原生的 <code>Proxy</code>，来解决之前所存在的一些问题。</p></blockquote>",5),h=e(`<h3 id="vue-如何检测数组的变化" tabindex="-1">Vue 如何检测数组的变化 <a class="header-anchor" href="#vue-如何检测数组的变化" aria-label="Permalink to &quot;Vue 如何检测数组的变化&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>Vue2.x 中是将数组的常用方法进行了重写</li></ul><p>Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。过程如下：</p><ol><li>初始化传入 data 数据执行 <code>initData</code></li><li>将数据进行观测 <code>new Observer</code></li><li>将数组原型方法<code>指向重写的原型</code></li><li>深度观察数组中的引用类型</li></ol></details><h3 id="无法检测数组时的解决方案" tabindex="-1">无法检测数组时的解决方案 <a class="header-anchor" href="#无法检测数组时的解决方案" aria-label="Permalink to &quot;无法检测数组时的解决方案&quot;">​</a></h3><details class="details custom-block"><summary>以下情况无法检测到数组的变化</summary><ol><li>当利用索引直接设置一个数组项时，例如 <code>vm.items[indexOfItem] = newValue</code>。可利用索引设置数组来解决：</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vm.$set，Vue.set的一个别名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.items, indexOfItem, newValue)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="2"><li>当修改数组的长度时，例如 <code>vm.items.length = newLength</code>。修改数组的长度的替代方案：</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Array.prototype.splice</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vm.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">splice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(indexOfItem, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newValue)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></details><h2 id="编译-compile" tabindex="-1">编译 Compile <a class="header-anchor" href="#编译-compile" aria-label="Permalink to &quot;编译 Compile&quot;">​</a></h2><h3 id="vue-模版编译原理" tabindex="-1">Vue 模版编译原理 <a class="header-anchor" href="#vue-模版编译原理" aria-label="Permalink to &quot;Vue 模版编译原理&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>Vue 中的模板 template 无法被浏览器解析并渲染，因为这不属于浏览器的标准，所以需要<code>将 template 转化成一个 JavaScript 函数</code>，这样浏览器就可以<code>执行这一个函数并渲染出对应的 HTML 元素</code>，这一个转化的过程，就称为<code>模板编译</code>。</p><p>模板编译又分三个阶段：</p><ul><li><code>解析阶段</code> <strong>parse</strong>：使用大量的正则表达式对 template 字符串进行解析，将标签、指令、属性等转化为抽象语法树 AST</li><li><code>优化阶段</code> <strong>optimize</strong>：遍历 AST，找到其中的一些静态节点并进行标记，方便 diff 比较时直接跳过这些静态节点，优化 runtime 的性能</li><li><code>生成阶段</code> <strong>generate</strong>：将最终的 AST 转化为 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数</li></ul></details><h3 id="computed-的实现原理" tabindex="-1">computed 的实现原理 <a class="header-anchor" href="#computed-的实现原理" aria-label="Permalink to &quot;computed 的实现原理&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理：它会<code>遍历 computed 配置中的所有属性</code>，为每一个属性创建一个 <code>Watcher</code> 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会<code>收集依赖</code>。</p><p>计算属性创建的 Watcher <code>不会立即执行</code>，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它<code>使用了 lazy 配置</code>，lazy 配置可以让 Watcher 不会立即执行。受到 lazy 影响，Watcher 内部会保存两个关键属性来<code>实现缓存</code>：</p><ul><li><code>value</code> 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined</li><li><code>dirty</code> 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true</li></ul><p>Watcher 创建好后，vue 会使用<code>代理模式</code>，将计算属性挂载到组件实例中。当读取计算属性时，vue <code>检查其对应的 Watcher</code> 是否是脏值：</p><ul><li>如果 dirty 为 true，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回；</li><li>如果 dirty 为 false，则直接返回 watcher 的 value。</li></ul><p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher。<code>当计算属性的依赖变化时</code>，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。</p><p>由于依赖同时会收集到组件的 Watcher，因此<code>组件会重新渲染</code>，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。</p></details><h2 id="双向绑定" tabindex="-1">双向绑定 <a class="header-anchor" href="#双向绑定" aria-label="Permalink to &quot;双向绑定&quot;">​</a></h2><h3 id="v-model-双向绑定的原理" tabindex="-1">v-model 双向绑定的原理 <a class="header-anchor" href="#v-model-双向绑定的原理" aria-label="Permalink to &quot;v-model 双向绑定的原理&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>v-model 本质就是：<strong>value + 对应方法 的语法糖</strong>。可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model，会根据标签的不同生成不同的事件和属性。例如：</p><ul><li>text 和 textarea 元素，使用 <code>value</code> 属性和 <code>input</code> 事件</li><li>checkbox 和 radio，使用 <code>checked</code> 属性和 <code>change</code> 事件</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件</li></ul><p>因此接下去我们执行以下 3 个步骤，实现数据的双向绑定：</p><ul><li>实现一个<code>监听器 Observer</code>，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li><li>实现一个<code>订阅者 Watcher</code>，可以收到属性的变化通知并执行相应的函数，从而更新视图。</li><li>实现一个<code>解析器 Compile</code>，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</li></ul></details><h3 id="vue-事件绑定原理" tabindex="-1">Vue 事件绑定原理 <a class="header-anchor" href="#vue-事件绑定原理" aria-label="Permalink to &quot;Vue 事件绑定原理&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>Vue 的事件绑定分为两种：</p><ul><li><p><strong>原生的事件绑定</strong></p><p>Vue 在创建 dom 时会调用 createEle，默认调用 invokeCreateHooks，针对事件会调用 updateDOMListeners，其中就有 add 方法，<code>核心使用 addEventListener 绑在 dom 上</code></p></li><li><p><strong>组件的事件绑定</strong> 组件实例化 -&gt; 获取到父给子绑定的<code>自定义事件</code> -&gt; <code>调用 updateListeners（传入 add 方法，核心使用 $on）</code></p></li></ul></details><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7208005892313579576#heading-4" target="_blank" rel="noreferrer">2023 高频前端面试题合集之 Vue（上篇）</a></li></ul>`,16);function p(m,b,k,v,_,g){const a=i("Image");return d(),s("div",null,[r,o("details",n,[u,l(a,{src:"/07vue/reactive.jpg",alt:"Vue响应式原理"})]),h])}const f=t(c,[["render",p]]);export{V as __pageData,f as default};
