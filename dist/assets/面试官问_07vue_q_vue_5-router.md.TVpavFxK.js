import{_ as e,c as o,o as a,V as r}from"./chunks/framework.ig3M3oij.js";const p=JSON.parse('{"title":"Vue Router 相关","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/07vue/q_vue_5-router.md","filePath":"面试官问/07vue/q_vue_5-router.md","lastUpdated":1708672862000}'),t={name:"面试官问/07vue/q_vue_5-router.md"},l=r('<h1 id="vue-router-相关" tabindex="-1">Vue Router 相关 <a class="header-anchor" href="#vue-router-相关" aria-label="Permalink to &quot;Vue Router 相关&quot;">​</a></h1><h2 id="history-api" tabindex="-1">history API <a class="header-anchor" href="#history-api" aria-label="Permalink to &quot;history API&quot;">​</a></h2><h3 id="了解浏览器-history-api-吗" tabindex="-1">了解浏览器 history API 吗 <a class="header-anchor" href="#了解浏览器-history-api-吗" aria-label="Permalink to &quot;了解浏览器 history API 吗&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li><p><code>window.history.back()</code> 后退</p></li><li><p><code>window.history.forward()</code> 前进</p></li><li><p><code>window.history.go(x) </code>前进或者后退 x 步</p></li></ul><blockquote><p>HTML5 history 新增了 2 个 API，可以在不进行刷新的情况下，操作浏览器的历史纪录</p></blockquote><ul><li><p><code>window.history.pushState()</code> 新增一个历史记录</p></li><li><p><code>window.history.repalceState()</code> 直接替换当前的历史记录</p></li></ul></details><h3 id="hash-和-history-模式的实现原理" tabindex="-1">hash 和 history 模式的实现原理 <a class="header-anchor" href="#hash-和-history-模式的实现原理" aria-label="Permalink to &quot;hash 和 history 模式的实现原理&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li># 后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；<code>通过监听 hashchange 事件</code>可以知道 hash 发生了哪些变化，然后<code>根据 hash 变化</code>来实现更新页面部分内容的操作。</li><li>history 模式的实现，主要是 HTML5 标准发布的两个 <code>API，pushState</code> 和 <code>replaceState</code> 这两个 API 可以在改变 URL，但是不会发送请求。这样就可以<code>监听 url 变化</code>来实现更新页面部分内容的操作。</li></ul></details><h3 id="hash-和-history-模式的区别" tabindex="-1">hash 和 history 模式的区别 <a class="header-anchor" href="#hash-和-history-模式的区别" aria-label="Permalink to &quot;hash 和 history 模式的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>首先是在 URL 的展示上，hash 模式有 <code>#</code>；history 模式没有</li><li>刷新页面时，hash 模式可以正常加载到 hash 值对应的页面；而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由</li><li>在兼容性上，hash 可以支持低版本浏览器和 IE</li></ul></details><h2 id="vue-router" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router" aria-label="Permalink to &quot;vue-router&quot;">​</a></h2><h3 id="说下-route-和-router-的区别" tabindex="-1">说下 $route 和 $router 的区别 <a class="header-anchor" href="#说下-route-和-router-的区别" aria-label="Permalink to &quot;说下 $route 和 $router 的区别&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li><p>$route 是<code>路由信息对象</code>，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</p></li><li><p>$router 是<code>路由实例对象</code>，是全局路由的实例，是 router 构造方法的实例。包括了 push、go、replace 等方法</p></li></ul></details><h3 id="vue-router-导航守卫" tabindex="-1">Vue-Router 导航守卫 <a class="header-anchor" href="#vue-router-导航守卫" aria-label="Permalink to &quot;Vue-Router 导航守卫&quot;">​</a></h3><p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p><details class="details custom-block"><summary>路由钩子</summary><p><code>全局路由钩子</code>：</p><ul><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.afterEach 全局后置钩子 进入路由之后</li><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 它会在导航将要被解析之前被执行。此时所有组件都已经获取完毕，且其它导航守卫也都已经完成调用。返回一个用来移除该守卫的函数。</li></ul><p><code>单个路由独享钩子</code>：</p><ul><li>beforeEnter 不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数 ∶ to、from、next</li></ul><p><code>组件内钩子</code>：</p><ul><li>beforeRouteEnter 进入组件前触发</li><li>beforeRouteUpdate 当前地址改变并且改组件被复用时触发。</li></ul><p>举例来说，带有动态参数的路径 foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的 foa 组件，这个钩子在这种情况下就会被调用</p><ul><li>beforeRouteLeave 离开组件被调用</li></ul><p>这三个钩子都有三个参数 ∶to、from、next</p></details><h3 id="vue-router-如何实现路由守卫" tabindex="-1">vue-router 如何实现路由守卫 <a class="header-anchor" href="#vue-router-如何实现路由守卫" aria-label="Permalink to &quot;vue-router 如何实现路由守卫&quot;">​</a></h3><p>路由保护在应用开发过程中非常重要，几乎每个应用都要做各种路由权限管理。所以回答和代码部分都有：</p><p>// todo: 代码编写</p><details class="details custom-block"><summary>详细信息</summary><ul><li>vue-router 中保护路由的方法叫做路由守卫，主要用来通过跳转或取消的方式守卫导航。</li><li>路由守卫有三个级别：全局、路由独享、组件级。影响范围由大到小，例如全局的 <code>router.beforeEach()</code>，可以注册一个全局前置守卫，每次路由导航都会经过这个守卫，因此在其内部可以加入控制逻辑决定用户是否可以导航到目标路由；在路由注册的时候可以加入单路由独享的守卫，例如 <code>beforeEnter</code>，守卫只在进入路由时触发，因此只会影响这个路由，控制更精确；我们还可以为路由组件添加守卫配置，例如 <code>beforeRouteEnter</code>，会在渲染该组件的对应路由被验证前调用，控制的范围更精确了。</li><li>用户的任何导航行为都会走 <code>navigate</code> 方法，内部有个 <code>guards</code> 队列按顺序执行用户注册的守卫钩子函数，如果没有通过验证逻辑则会取消原有的导航。</li></ul></details><h3 id="vuerouter-的完整的导航解析流程是什么" tabindex="-1">vueRouter 的完整的导航解析流程是什么 <a class="header-anchor" href="#vuerouter-的完整的导航解析流程是什么" aria-label="Permalink to &quot;vueRouter 的完整的导航解析流程是什么&quot;">​</a></h3><details class="details custom-block"><summary>完整的路由导航解析流程（不包括其他生命周期）</summary><ol><li>触发进入路由</li><li>调用要离开路由的组件守卫 <code>beforeRouteLeave</code></li><li>调用全局前置守卫 <code>beforeEach</code></li><li>在重用的组件里调用 <code>beforeRouteUpdate</code></li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件</li><li>在将要进入的路由组件中调用 <code>beforeRouteEnter</code></li><li>调用全局解析守卫 <code>beforeResolve</code></li><li>导航被确认</li><li>调用全局的 <code>afterEach</code> 钩子</li><li><code>触发 DOM 更新</code> mounted</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 <code>next</code> 的<code>回调函数</code></li></ol></details><h3 id="触发钩子的完整顺序" tabindex="-1">触发钩子的完整顺序 <a class="header-anchor" href="#触发钩子的完整顺序" aria-label="Permalink to &quot;触发钩子的完整顺序&quot;">​</a></h3><details class="details custom-block"><summary>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从 a 组件离开，第一次进入 b 组件 ∶</summary><ol><li><code>beforeRouteLeave</code> 路由组件的组件离开路由前钩子，可取消路由离开。</li><li><code>beforeEach</code> 路由全局前置守卫，可用于登录验证、全局路由 loading 等。</li><li><code>beforeEnter</code> 路由独享守卫</li><li><code>beforeRouteEnter</code> 路由组件的组件进入路由前钩子。</li><li><code>beforeResolve</code> 路由全局解析守卫</li><li><code>afterEach</code> 路由全局后置钩子</li><li><code>beforeCreate</code> 组件生命周期，不能访问 this。</li><li><code>created</code> 组件生命周期，可以访问 this，不能访问 dom。</li><li><code>beforeMount</code> 组件生命周期</li><li><code>deactivated</code> 离开缓存组件 a，或者触发 a 的 beforeDestroy 和 destroyed 组件销毁钩子。</li><li><code>mounted</code> 访问或操作 dom。</li><li><code>activated</code> 进入缓存组件，进入 a 的嵌套子组件（如果有的话）。</li><li>执行 <code>beforeRouteEnter</code> 回调函数 next。</li></ol></details><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7275608678827868179" target="_blank" rel="noreferrer">2023 前端 Vue 面试题汇总</a></li></ul>',24),i=[l];function d(c,u,s,h,n,m){return a(),o("div",null,i)}const f=e(t,[["render",d]]);export{p as __pageData,f as default};
