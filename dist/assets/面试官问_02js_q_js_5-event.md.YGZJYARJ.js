import{_ as e,c as a,o as t,V as l}from"./chunks/framework.GzbH9VPN.js";const p=JSON.parse('{"title":"事件 Event","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/02js/q_js_5-event.md","filePath":"面试官问/02js/q_js_5-event.md","lastUpdated":1708509699000}'),i={name:"面试官问/02js/q_js_5-event.md"},s=l('<h1 id="事件-event" tabindex="-1">事件 Event <a class="header-anchor" href="#事件-event" aria-label="Permalink to &quot;事件 Event&quot;">​</a></h1><p>温故知新 <a href="./../../直击概念/02js/s_js_5-event.html">直击概念 - 事件 Event</a></p><h2 id="事件机制" tabindex="-1">事件机制 <a class="header-anchor" href="#事件机制" aria-label="Permalink to &quot;事件机制&quot;">​</a></h2><h3 id="说一下-js-的事件机制" tabindex="-1">说一下 JS 的事件机制 <a class="header-anchor" href="#说一下-js-的事件机制" aria-label="Permalink to &quot;说一下 JS 的事件机制&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><ul><li>事件发生时会在元素节点之间按照特定的顺序传播，就是 DOM 事件流。</li><li>通常，一个事件会从父元素开始向目标元素传播，然后它将被传播回父元素。</li><li>包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</li></ul></details><h3 id="什么是事件捕获" tabindex="-1">什么是事件捕获 <a class="header-anchor" href="#什么是事件捕获" aria-label="Permalink to &quot;什么是事件捕获&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>事件捕获（event capturing）： 当鼠标点击或者触发 dom 事件时（被触发 dom 事件的这个元素被叫作事件源），浏览器会从根节点 =&gt; 事件源 <code>由外到内进行事件传播</code>。</p><p>事件捕获与事件冒泡是比较类似的，最大的不同在于事件传播的方向。</p></details><h3 id="什么是事件冒泡" tabindex="-1">什么是事件冒泡 <a class="header-anchor" href="#什么是事件冒泡" aria-label="Permalink to &quot;什么是事件冒泡&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>事件冒泡（dubbed bubbling）：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 window （注意这里传递的仅仅是事件，例如 click、focus 等等这些事件，  并不传递所绑定的事件函数。）</p><p>事件源 =&gt; 根节点 <code>由内到外进行事件传播</code>。</p></details><h3 id="什么是事件委托" tabindex="-1">什么是事件委托 <a class="header-anchor" href="#什么是事件委托" aria-label="Permalink to &quot;什么是事件委托&quot;">​</a></h3><details class="details custom-block"><summary>详细信息</summary><p>事件委托也称为事件代理。就是<code>利用事件冒泡，把子元素的事件都绑定到父元素上</code>。如果子元素阻止了事件冒泡，那么委托就无法实现。</p><p><strong>优点：</strong></p><ol><li><p><strong>替代循环绑定事件的操作，减少内存消耗，提高性能</strong>。比如：</p><ul><li>在 table 上代理所有 td 的 click 事件。</li><li>在 ul 上代理所有 li 的 click 事件。</li></ul></li><li><p><strong>简化了 dom 节点更新时，相应事件的更新</strong>。比如：</p><ul><li>不用在新添加的 li 上绑定 click 事件。</li><li>当删除某个 li 时，不用移解绑上面的 click 事件。</li></ul></li></ol><p><strong>缺点：</strong></p><ol><li><code>事件委托基于冒泡</code>，对于不冒泡的事件不支持。</li><li>层级过多，冒泡过程中，可能会被某层阻止掉。</li><li>理论上委托会导致浏览器<code>频繁调用处理函数</code>，虽然很可能不需要处理。所以建议<code>就近委托</code>，比如在 table 上代理 td，而不是在 document 上代理 td。</li></ol></details><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7192584563799883832" target="_blank" rel="noreferrer">JS 中的事件冒泡、事件捕获、事件委托</a></li></ul>',13),o=[s];function r(c,d,n,u,h,m){return t(),a("div",null,o)}const b=e(i,[["render",r]]);export{p as __pageData,b as default};
