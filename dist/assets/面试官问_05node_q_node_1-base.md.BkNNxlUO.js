import{_ as c,E as s,c as l,J as o,V as a,m as d,a as t,o as i}from"./chunks/framework.CMKosmpS.js";const k=JSON.parse('{"title":"Node.js 基础","description":"","frontmatter":{},"headers":[],"relativePath":"面试官问/05node/q_node_1-base.md","filePath":"面试官问/05node/q_node_1-base.md","lastUpdated":1709785699000}'),r={name:"面试官问/05node/q_node_1-base.md"},n=a('<h1 id="node-js-基础" tabindex="-1">Node.js 基础 <a class="header-anchor" href="#node-js-基础" aria-label="Permalink to &quot;Node.js 基础&quot;">​</a></h1><h2 id="说一下-node-js-的主要优点" tabindex="-1">说一下 Node.js 的主要优点 <a class="header-anchor" href="#说一下-node-js-的主要优点" aria-label="Permalink to &quot;说一下 Node.js 的主要优点&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><ul><li><p><code>异步编程模型</code>：Node.js 采用了事件驱动、非阻塞 I/O 模型，使其能够在大量连接的情况下保持高性能和稳定性。</p></li><li><p><code>单一编程语言</code>：Node.js 使用的是 <code>JavaScript</code>，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。</p></li><li><p><code>开源社区活跃</code>：Node.js 有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。</p></li><li><p><code>跨平台性</code>：Node.js 可以在多种操作系统上运行，如 Windows、Linux、macOS 等。</p></li><li><p><code>高性能</code>：由于 Node.js 的<code>非阻塞 I/O 模型</code>，使其在处理大量并发请求时具有极高的性能。</p></li><li><p><code>数据密集型</code>应用：Node.js 擅长处理数据密集型应用，如<code>实时通信</code>、<code>实时流媒体</code>、实时游戏等。</p></li></ul><p>综上所述，Node.js 凭借其独特的<code>异步编程模型</code>和强大的社区支持，成为了一种优秀的<code>服务器端</code>技术选择。</p></details><h2 id="node-js-的事件循环" tabindex="-1">Node.js 的事件循环 <a class="header-anchor" href="#node-js-的事件循环" aria-label="Permalink to &quot;Node.js 的事件循环&quot;">​</a></h2><h3 id="浏览器的时间循环处理" tabindex="-1">浏览器的时间循环处理 <a class="header-anchor" href="#浏览器的时间循环处理" aria-label="Permalink to &quot;浏览器的时间循环处理&quot;">​</a></h3>',5),p=d("h3",{id:"node-的事件循环处理",tabindex:"-1"},[t("Node 的事件循环处理 "),d("a",{class:"header-anchor",href:"#node-的事件循环处理","aria-label":'Permalink to "Node 的事件循环处理"'},"​")],-1),h=a('<ul><li><code>timers</code> 阶段</li></ul><p>在 timers 阶段会执行已经被  setTimeout()  和  setInterval()  的调度回调函数。</p><ul><li><code>pending callbacks</code> 阶段</li></ul><p>上一次循环队列中，还未执行完毕的会在这个阶段进行执行。比如延迟到下一个 Loop 之中的 I/O 操作。</p><ul><li><code>idle</code> 、 <code>prepare</code></li></ul><p>其实这一步我们不需要过多的关系，它仅仅是在 NodeJs 内部调用。我们无法进行操作这一步，所以我们仅仅了解存在 idle prepare 这一层即可。</p><ul><li><code>poll</code></li></ul><p>这一阶段被称为轮询阶段，它主要会检测新的 I/O 相关的回调，需要注意的是这一阶段会存在阻塞（也就意味着这之后的阶段可能不会被执行）</p><ul><li><code>check</code></li></ul><p>check 阶段会检测 setImmediate()  回调函数在这个阶段进行执行。</p><ul><li><code>close callbacks</code></li></ul><p>这个阶段会执行一系列关闭的回调函数，比如如：socket.on(&#39;close&#39;, ...)。 其实 NodeJs 中的事件循环机制主要就是基于以上几个阶段，但是对于我们比较重要的来说仅仅只有 timers、poll 和 check 阶段，因为这三个阶段影响着我们代码书写的执行顺序。</p><p>至于 pending callbacks、idle, prepare 、close callbacks 其实对于我们代码的执行顺序并不存在什么强耦合，甚至有些时候我们完全不必在意他们。</p><h2 id="如何在-node-js-中处理-http-请求和响应" tabindex="-1">如何在 Node.js 中处理 HTTP 请求和响应 <a class="header-anchor" href="#如何在-node-js-中处理-http-请求和响应" aria-label="Permalink to &quot;如何在 Node.js 中处理 HTTP 请求和响应&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><p>在 Node.js 中处理 HTTP 请求和响应的基本流程如下：</p><ol><li>创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数。</li><li>监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件接收客户端发送来的 HTTP 请求。</li><li>处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。</li><li>设置响应头和状态码。接着需要设置响应头和状态码，并将响应内容写入响应体中。</li><li>发送响应到客户端。最后需要使用 <code>response.end()</code> 方法将响应发送回客户端。</li></ol><p>通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。 需要注意的是，由于 Node.js 是<code>单线程模型</code>，因此在<code>同一时刻</code>只能<code>处理一个</code>请求。为了能够同时处理多个请求，可以通过<code>集群</code>、<code>负载均衡</code>等方式将多个请求分发到不同的 Node.js 进程中进行处理。</p></details><h2 id="说说-node-js的集群化工作模式" tabindex="-1">说说 Node.js的集群化工作模式 <a class="header-anchor" href="#说说-node-js的集群化工作模式" aria-label="Permalink to &quot;说说 Node.js的集群化工作模式&quot;">​</a></h2><details class="details custom-block"><summary>详细信息</summary><p>Node.js 的集群化工作模式是一种<code>利用多个进程</code>同时运行 Node.js 应用来<code>实现负载均衡</code>的技术。它可以充分利用<code>多核 CPU 的计算能力</code>，并且可以<code>减少单个进程的压力</code>，从而<strong>提高应用的可用性和性能</strong>。</p><p>在 Node.js 中，可以使用内置的 <code>cluster</code> 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 <code>cluster.fork()</code> 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。</p><p>此外，Node.js 还提供了一些<code>内置的策略</code>来实现负载均衡，如 <code>round-robin</code> 和 <code>least-connections</code> 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。</p><p>总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。</p></details><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7309158181841829938" target="_blank" rel="noreferrer">面试宝典-NodeJs 面试题合集</a></li><li><a href="https://juejin.cn/post/7077122129107353636?searchId=20240307121644574CCF4D4A751480DB31" target="_blank" rel="noreferrer">「多图详解」NodeJs 中 EventLoop 与浏览器下的差异性</a>——19 组清风</li></ul>',19);function u(_,m,j,N,T,b){const e=s("Image");return i(),l("div",null,[n,o(e,{src:"../../public/05node/eventloop-bw.png",alt:"浏览器的事件循环"}),p,o(e,{src:"../../public/05node/eventloop-node.png",alt:"Node的事件循环"}),h])}const f=c(r,[["render",u]]);export{k as __pageData,f as default};
